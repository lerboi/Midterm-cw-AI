================================================================================
                        COURSEWORK PART B - CHANGES LOG
                    Mountain Climbing Genetic Algorithm
================================================================================

This file documents ALL changes made to the original codebase to adapt it
for the mountain climbing task in Part B of the coursework.

Each entry contains:
1. HIGH-LEVEL SUMMARY - What was changed and why
2. FUNCTION-LEVEL DESCRIPTIONS - Which functions/methods were added/modified
3. LINE-BY-LINE CODE CHANGES - Actual code snippets showing modifications

================================================================================
CHANGE #1: Added Height Tracking to Creature Class
Date: 2024-12-14
File: creature.py
Reason: Need to track maximum height achieved for mountain climbing fitness
        instead of horizontal distance traveled
================================================================================

HIGH-LEVEL SUMMARY:
- Added max_height attribute to Creature class to track the highest z-coordinate
  reached during simulation
- Added method to update maximum height whenever creature position is updated
- Added method to retrieve final maximum height for fitness calculation
- Modified update_dna() to reset max_height when DNA is updated

FUNCTION-LEVEL CHANGES:

1. Modified __init__(self, gene_count)
   - Added: self.max_height = 0
   - Purpose: Initialize maximum height tracking at zero

2. Added update_max_height(self, pos)
   - New method to update max_height if current z-coordinate is higher
   - Called during simulation whenever position is updated
   
3. Added get_max_height(self)
   - New method to return the maximum height achieved
   - Used as fitness function for mountain climbing

4. Modified update_dna(self, dna)
   - Added: self.max_height = None
   - Purpose: Reset max_height when creature DNA is updated for next generation

LINE-BY-LINE CODE CHANGES:

LOCATION: creature.py, class Creature, __init__ method
BEFORE (line ~33):
        self.motors = None
        self.start_position = None
        self.last_position = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0  # NEW: Track maximum height for mountain climbing

---

LOCATION: creature.py, class Creature, new method after update_position
NEW METHOD ADDED (after line ~58):
    def update_max_height(self, pos):
        """
        Update the maximum height achieved by the creature.
        This is used for mountain climbing fitness.
        
        Args:
            pos: tuple of (x, y, z) coordinates
        """
        if pos is not None and len(pos) >= 3:
            current_height = pos[2]  # z-coordinate is height
            if current_height > self.max_height:
                self.max_height = current_height

---

LOCATION: creature.py, class Creature, new method after update_max_height
NEW METHOD ADDED:
    def get_max_height(self):
        """
        Get the maximum height achieved by the creature.
        Used as fitness function for mountain climbing.
        
        Returns:
            float: Maximum z-coordinate reached during simulation
        """
        return self.max_height

---

LOCATION: creature.py, class Creature, update_dna method
BEFORE (line ~68):
        self.motors = None
        self.start_position = None
        self.last_position = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0  # NEW: Reset max height for new DNA

================================================================================
END OF CHANGE #1
================================================================================


================================================================================
CHANGE #2: Modified Simulation for Mountain Climbing
Date: 2024-12-14
File: simulation.py (MODIFIED)
Reason: Need to replace flat plane environment with mountain terrain for
        mountain climbing task and track maximum height instead of distance
================================================================================

HIGH-LEVEL SUMMARY:
- Modified existing simulation.py file to support mountain climbing
- Replaced flat plane environment with arena + mountain setup from cw-envt.py
- Added helper functions to create arena walls and load mountain
- Modified run_creature() to track max height during simulation
- Modified run_creature() to call update_max_height() on creatures
- Set additional search path for loading mountain URDF files from shapes/ folder

FUNCTION-LEVEL CHANGES:

1. Added make_arena(arena_size, wall_height, physicsClientId)
   - New helper function at end of file
   - Creates sandbox arena with floor and four walls
   - Returns floor body ID
   
2. Added load_mountain(mountain_file, position, orientation, physicsClientId)
   - New helper function at end of file
   - Loads mountain URDF file from shapes/ directory
   - Returns mountain body ID

3. Modified run_creature(self, cr, iterations)
   - Replaced plane creation with arena + mountain setup
   - Added search path for shapes/ directory
   - Added call to cr.update_max_height(pos) during simulation loop
   - Changed starting position from [0, 0, 2.5] to [0, 0, 10]

4. Kept update_motors() unchanged
   - No changes needed for motor control

5. Kept eval_population() unchanged
   - No changes needed for population evaluation

6. ThreadedSim class kept unchanged
   - Works with the new simulation automatically

LINE-BY-LINE CODE CHANGES:

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (lines ~13-15):
        p.setGravity(0, 0, -10, physicsClientId=pid)
        plane_shape = p.createCollisionShape(p.GEOM_PLANE, physicsClientId=pid)
        floor = p.createMultiBody(plane_shape, plane_shape, physicsClientId=pid)

AFTER:
        p.setGravity(0, 0, -10, physicsClientId=pid)
        
        # Create arena and mountain environment instead of flat plane
        arena_size = 20
        make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
        
        # Set search path for mountain URDF files
        p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
        
        # Load mountain
        mountain_position = (0, 0, -1)
        mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
        load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

---

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (line ~23):
        p.resetBasePositionAndOrientation(cid, [0, 0, 2.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
        # Start creature at height 10 to drop onto mountain
        p.resetBasePositionAndOrientation(cid, [0, 0, 10], [0, 0, 0, 1], physicsClientId=pid)

---

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (lines ~30-33):
            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            #print(pos[2])
            #print(cr.get_distance_travelled())

AFTER:
            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            cr.update_max_height(pos)  # Track maximum height for mountain climbing

---

LOCATION: simulation.py, end of file (after ThreadedSim class)
NEW HELPER FUNCTIONS ADDED:

(See full code in next section)

================================================================================
END OF CHANGE #2
================================================================================


================================================================================
CHANGE #3: Created Mountain Climbing GA Test Script
Date: 2024-12-14
File: test_ga_mountain.py (NEW FILE)
Reason: Need a GA script that uses get_max_height() as fitness function instead
        of get_distance_travelled() for mountain climbing evolution
================================================================================

HIGH-LEVEL SUMMARY:
- Created new file test_ga_mountain.py based on test_ga_no_threads.py
- Modified fitness evaluation to use get_max_height() instead of get_distance_travelled()
- Changed elite creature filename to "elite_mountain_" prefix
- Kept same GA parameters (population size, gene count, mutation rates)
- Kept same structure: population creation, simulation, selection, crossover, mutation, elitism

FUNCTION-LEVEL CHANGES:

1. Modified testBasicGA() method
   - Changed fitness calculation from cr.get_distance_travelled() to cr.get_max_height()
   - Changed print statement to show "max height" instead of "fittest"
   - Changed elite filename from "elite_" to "elite_mountain_"
   - All other GA logic remains identical

2. No changes to:
   - Population creation (pop_size=10, gene_count=3)
   - Simulation setup (Simulation() class)
   - Selection process (get_fitness_map, select_parent)
   - Crossover and mutation (same rates)
   - Elitism implementation

LINE-BY-LINE CODE CHANGES:

LOCATION: test_ga_mountain.py (NEW FILE)
This is based on test_ga_no_threads.py with minimal changes.

BEFORE (from test_ga_no_threads.py, line ~23):
            fits = [cr.get_distance_travelled() 
                    for cr in pop.creatures]

AFTER:
            fits = [cr.get_max_height() 
                    for cr in pop.creatures]

---

BEFORE (from test_ga_no_threads.py, line ~27):
            print(iteration, "fittest:", np.round(np.max(fits), 3), 
                  "mean:", np.round(np.mean(fits), 3), "mean links", np.round(np.mean(links)), "max links", np.round(np.max(links)))

AFTER:
            print(iteration, "max height:", np.round(np.max(fits), 3), 
                  "mean:", np.round(np.mean(fits), 3), "mean links", np.round(np.mean(links)), "max links", np.round(np.max(links)))

---

BEFORE (from test_ga_no_threads.py, line ~44):
            max_fit = np.max(fits)
            for cr in pop.creatures:
                if cr.get_distance_travelled() == max_fit:
                    new_cr = creature.Creature(1)
                    new_cr.update_dna(cr.dna)
                    new_creatures[0] = new_cr
                    filename = "elite_"+str(iteration)+".csv"
                    genome.Genome.to_csv(cr.dna, filename)
                    break

AFTER:
            max_fit = np.max(fits)
            for cr in pop.creatures:
                if cr.get_max_height() == max_fit:
                    new_cr = creature.Creature(1)
                    new_cr.update_dna(cr.dna)
                    new_creatures[0] = new_cr
                    filename = "elite_mountain_"+str(iteration)+".csv"
                    genome.Genome.to_csv(cr.dna, filename)
                    break

================================================================================
END OF CHANGE #3
================================================================================


================================================================================
CHANGE #4: Created Parameter Experiment Scripts
Date: 2024-12-14
Files: experiment_population_size.py (NEW FILE)
       experiment_gene_count.py (NEW FILE)
       experiment_mutation_rates.py (NEW FILE)
Reason: Basic requirement - Need to test different GA and genome settings
        and collect data for graphs/tables showing how settings affect climbing
================================================================================

HIGH-LEVEL SUMMARY:
- Created three experiment scripts to test different GA parameters
- Each script runs the GA with different parameter values and saves results
- Results saved to CSV files in results/ folder for later analysis
- Data includes: generation number, max fitness, mean fitness, max links, mean links
- Scripts based on test_ga_mountain.py with data collection added

EXPERIMENT SCRIPTS:

1. experiment_population_size.py
   - Tests population sizes: 5, 10, 20, 50
   - Gene count fixed at 3
   - Runs 500 generations for each population size
   - Saves results to: results/pop_size_{size}.csv

2. experiment_gene_count.py
   - Tests gene counts: 2, 3, 5, 10
   - Population size fixed at 10
   - Runs 500 generations for each gene count
   - Saves results to: results/gene_count_{count}.csv

3. experiment_mutation_rates.py
   - Tests different mutation rate combinations
   - Population size fixed at 10, gene count fixed at 3
   - Runs 500 generations for each rate combination
   - Saves results to: results/mutation_point_{rate}_shrink_{rate}_grow_{rate}.csv
   - Tests:
     * Low rates: point=0.05, shrink=0.1, grow=0.05
     * Medium rates: point=0.1, shrink=0.25, grow=0.1 (baseline)
     * High rates: point=0.25, shrink=0.5, grow=0.25

FUNCTION-LEVEL CHANGES:

1. Added save_results() helper function
   - Saves generation data to CSV file
   - Creates results/ directory if it doesn't exist
   - Appends data row by row during evolution

2. Modified testBasicGA() in each experiment
   - Loops through different parameter values
   - Collects fitness and link statistics each generation
   - Saves data to CSV files
   - Prints progress to console

3. Added data collection during GA loop
   - Records: iteration, max_fit, mean_fit, max_links, mean_links
   - Saves elite creature DNA to elite_creatures/ folder

LINE-BY-LINE CODE CHANGES:

All three files are new, based on test_ga_mountain.py with these additions:

NEW HELPER FUNCTION (added to all experiment scripts):
def save_results(filename, generation, max_fit, mean_fit, max_links, mean_links):
    """Save experiment results to CSV file"""
    import os
    os.makedirs("results", exist_ok=True)
    filepath = os.path.join("results", filename)
    
    # Create file with headers if it doesn't exist
    if not os.path.exists(filepath):
        with open(filepath, 'w') as f:
            f.write("generation,max_fitness,mean_fitness,max_links,mean_links\n")
    
    # Append data
    with open(filepath, 'a') as f:
        f.write(f"{generation},{max_fit},{mean_fit},{max_links},{mean_links}\n")

MODIFIED GA LOOP (example from experiment_population_size.py):
for pop_size in [5, 10, 20, 50]:
    print(f"\n{'='*60}")
    print(f"Testing Population Size: {pop_size}")
    print(f"{'='*60}\n")
    
    pop = population.Population(pop_size=pop_size, gene_count=3)
    sim = simulation.Simulation()
    
    for iteration in range(500):
        # ... GA loop ...
        
        # Save results after each generation
        save_results(
            f"pop_size_{pop_size}.csv",
            iteration,
            np.max(fits),
            np.mean(fits),
            np.max(links),
            np.mean(links)
        )

================================================================================
END OF CHANGE #4
================================================================================


================================================================================
CHANGE #5: Created Visualization Script for Graphs and Tables
Date: 2024-12-14
File: create_graphs.py (NEW FILE)
Reason: Basic requirement - Need to produce graphs and tables describing how
        different settings affect mountain climbing performance
================================================================================

HIGH-LEVEL SUMMARY:
- Created visualization script to analyze experimental results
- Generates line graphs showing fitness over generations for each parameter
- Creates comparison plots showing all configurations on same graph
- Produces summary tables with key statistics
- Saves all outputs to graphs/ folder

FEATURES:

1. Line Graphs for Each Experiment
   - Population size experiments: 4 separate graphs
   - Gene count experiments: 4 separate graphs
   - Mutation rate experiments: 3 separate graphs
   - Shows max fitness and mean fitness over time

2. Comparison Plots
   - All population sizes on one graph
   - All gene counts on one graph
   - All mutation configurations on one graph
   - Easy visual comparison of different settings

3. Summary Tables
   - Creates CSV files with statistics for each experiment
   - Includes: final max fitness, final mean fitness, peak generation
   - Saved to graphs/summary_*.csv

FUNCTION-LEVEL CHANGES:

1. plot_single_experiment(csv_file, title, output_file)
   - Reads CSV data from results/ folder
   - Creates line plot with max and mean fitness
   - Saves to graphs/ folder

2. plot_comparison(csv_files, labels, title, output_file)
   - Plots multiple experiments on same graph
   - Different colors for each configuration
   - Includes legend for identification

3. create_summary_table(csv_files, labels, output_file)
   - Analyzes final results from each experiment
   - Creates summary statistics table
   - Saves to CSV for inclusion in report

4. main()
   - Orchestrates all visualization tasks
   - Calls plotting functions for each experiment type
   - Creates all graphs and tables

LINE-BY-LINE CODE CHANGES:

LOCATION: create_graphs.py (NEW FILE)
This is a completely new file.

Key libraries used:
- matplotlib.pyplot for plotting
- pandas for data handling
- numpy for statistics

Output structure:
- graphs/pop_size_*.png (individual plots)
- graphs/pop_size_comparison.png (comparison plot)
- graphs/gene_count_*.png (individual plots)
- graphs/gene_count_comparison.png (comparison plot)
- graphs/mutation_*.png (individual plots)
- graphs/mutation_comparison.png (comparison plot)
- graphs/summary_population.csv (statistics table)
- graphs/summary_genes.csv (statistics table)
- graphs/summary_mutation.csv (statistics table)

================================================================================
END OF CHANGE #5
================================================================================


================================================================================
CHANGE #6: Reorganized Experiments and Created Main Orchestrator Script
Date: 2024-12-14
Files: experiments/experiment_population_size.py (MOVED & MODIFIED)
       experiments/experiment_gene_count.py (MOVED & MODIFIED)
       experiments/experiment_mutation_rates.py (MOVED & MODIFIED)
       experiments/create_graphs.py (MOVED & MODIFIED)
       run_all_experiments.py (NEW FILE - ROOT)
Reason: Organize experiment files and create single script to run all
        experiments and generate graphs automatically
================================================================================

HIGH-LEVEL SUMMARY:
- Created experiments/ folder to organize all experiment and visualization scripts
- Moved all experiment scripts into experiments/ folder
- Modified experiment scripts to be both standalone runnable AND importable
- Modified create_graphs.py to auto-display graphs and be importable
- Created run_all_experiments.py as main orchestrator in root folder
- Updated all file paths to work with new folder structure

FOLDER STRUCTURE:
experiments/
  ├── experiment_population_size.py
  ├── experiment_gene_count.py
  ├── experiment_mutation_rates.py
  └── create_graphs.py

root/
  └── run_all_experiments.py (NEW)

results/ (created automatically)
graphs/ (created automatically)
elite_creatures/ (created automatically)

MODIFICATIONS TO EXPERIMENT SCRIPTS:

1. Added run_population_experiments() function
   - Extracted logic from testPopulationSizes()
   - Can be called from external scripts
   - Returns nothing, saves results to CSV

2. Modified file paths
   - Changed "results/" to "../results/" (parent directory)
   - Changed "elite_creatures/" to "../elite_creatures/"

3. Wrapped unittest.main() in if __name__ == "__main__"
   - Allows standalone execution
   - Prevents auto-run when imported

MODIFICATIONS TO CREATE_GRAPHS.PY:

1. Added generate_all_graphs() function
   - Wrapper for main() function
   - Can be called from external scripts

2. Added display_comparison_graphs() function
   - Opens comparison plots with plt.show()
   - Displays graphs in popup windows

3. Modified file paths
   - Changed "results/" to "../results/"
   - Changed "graphs/" to "../graphs/"

4. Modified plotting functions
   - Auto-display graphs after saving
   - Use plt.show() for comparison plots

NEW RUN_ALL_EXPERIMENTS.PY:

1. Main orchestrator script
   - Imports experiment modules
   - Runs all experiments sequentially
   - Generates graphs automatically
   - Displays comparison graphs

2. Features
   - Simple text progress output
   - Error handling for each step
   - Clear completion messages

LINE-BY-LINE CODE CHANGES:

LOCATION: experiments/experiment_population_size.py
ADDED NEW FUNCTION (before class TestGA):

def run_population_experiments():
    """Run population size experiments - callable from other scripts"""
    # ... (extracted from testPopulationSizes)

MODIFIED: File paths
BEFORE: "results/pop_size_{pop_size}.csv"
AFTER: "../results/pop_size_{pop_size}.csv"

BEFORE: "elite_creatures/pop_{pop_size}_gen_{iteration}.csv"
AFTER: "../elite_creatures/pop_{pop_size}_gen_{iteration}.csv"

MODIFIED: unittest.main() call
BEFORE (at end of file):
unittest.main()

AFTER:
if __name__ == "__main__":
    unittest.main()

---

SIMILAR CHANGES FOR:
- experiments/experiment_gene_count.py (added run_gene_experiments())
- experiments/experiment_mutation_rates.py (added run_mutation_experiments())

---

LOCATION: experiments/create_graphs.py
ADDED NEW FUNCTIONS:

def generate_all_graphs():
    """Generate all graphs - callable from other scripts"""
    main()

def display_comparison_graphs():
    """Display comparison graphs in popup windows"""
    # Opens the 3 main comparison plots

MODIFIED: All file paths
BEFORE: "results/"
AFTER: "../results/"

BEFORE: "graphs/"
AFTER: "../graphs/"

MODIFIED: plot_comparison() function
ADDED at end: plt.show() to display graph

---

LOCATION: run_all_experiments.py (NEW FILE IN ROOT)
Complete new orchestrator script that:
1. Runs all experiments
2. Generates graphs
3. Displays results

================================================================================
END OF CHANGE #6
================================================================================


================================================================================
CHANGE #7: Fixed Fitness Function to Track Absolute Maximum Height
Date: 2024-12-14
Files: creature.py (MODIFIED)
       simulation.py (MODIFIED)
       realtime_from_csv.py (MODIFIED)
Reason: Fix incorrect fitness calculation - should track absolute maximum
        Z-coordinate (closeness to mountain peak), not relative climb from
        random landing position
================================================================================

HIGH-LEVEL SUMMARY:
- Removed baseline height tracking that was causing incorrect fitness
- Changed spawning from z=10 (drop) to z=0.5 (base of mountain)
- Implemented two-phase simulation: settling + tracking
- Fitness now measures absolute maximum height reached (correct per PDF)
- All creatures start from same position (fair comparison)

PROBLEM IDENTIFIED:
Previous implementation tracked height relative to landing position:
- Creatures dropped from z=10 with random bouncing
- Baseline set to wherever creature landed (inconsistent)
- Fitness = relative climb from baseline (wrong metric)
- Rewarded "landing low + small climb" over "reaching actual peak"
- Caused creatures to grow larger instead of learning to climb

SOLUTION IMPLEMENTED:
New implementation tracks absolute maximum Z-coordinate:
- Creatures spawn at mountain base z=0.5 (consistent start)
- Brief settling period (0.5 seconds)
- Track absolute max Z during simulation
- Fitness = highest Z-coordinate reached (correct per PDF requirement)
- Directly measures "maximum closeness to top of mountain"

FUNCTION-LEVEL CHANGES:

1. creature.py - Removed baseline tracking
   - Removed self.baseline_height attribute from __init__
   - Simplified update_max_height() to track absolute max Z only
   - Removed baseline from update_dna()

2. simulation.py - Changed spawn position and tracking
   - Changed spawn from z=10 to z=0.5 (mountain base)
   - Added two-phase simulation (settling + tracking)
   - Reset max_height to 0 after settling phase
   - Track absolute height throughout main simulation

3. realtime_from_csv.py - Same fixes for playback
   - Changed spawn from z=10 to z=0.5
   - Removed baseline tracking
   - Display absolute Z-coordinates

LINE-BY-LINE CODE CHANGES:

LOCATION: creature.py, class Creature, __init__ method
BEFORE (line ~33):
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0
        self.baseline_height = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0

---

LOCATION: creature.py, class Creature, update_max_height method
BEFORE (entire method):
    def update_max_height(self, pos):
        """
        Update the maximum height achieved by the creature.
        This is used for mountain climbing fitness.
        
        Args:
            pos: tuple of (x, y, z) coordinates
        """
        if pos is not None and len(pos) >= 3:
            # Set baseline on first call (where creature landed)
            if self.baseline_height is None:
                self.baseline_height = pos[2]
                self.max_height = 0  # Start from 0 relative to landing
            else:
                # Track height relative to baseline (landing position)
                relative_height = pos[2] - self.baseline_height
                if relative_height > self.max_height:
                    self.max_height = relative_height

AFTER:
    def update_max_height(self, pos):
        """
        Update the maximum height achieved by the creature.
        Tracks absolute maximum Z-coordinate for mountain climbing fitness.
        
        Args:
            pos: tuple of (x, y, z) coordinates
        """
        if pos is not None and len(pos) >= 3:
            current_height = pos[2]  # Absolute Z-coordinate
            if current_height > self.max_height:
                self.max_height = current_height

---

LOCATION: creature.py, class Creature, update_dna method
BEFORE (line ~68):
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0
        self.baseline_height = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0

---

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (entire method - line ~10-43):
    def run_creature(self, cr, iterations=2400):
        pid = self.physicsClientId
        p.resetSimulation(physicsClientId=pid)
        p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)

        p.setGravity(0, 0, -10, physicsClientId=pid)
        
        # Create arena and mountain environment instead of flat plane
        arena_size = 20
        make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
        
        # Set search path for mountain URDF files
        p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
        
        # Load mountain
        mountain_position = (0, 0, -1)
        mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
        load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

        xml_file = 'temp' + str(self.sim_id) + '.urdf'
        xml_str = cr.to_xml()
        with open(xml_file, 'w') as f:
            f.write(xml_str)
        
        cid = p.loadURDF(xml_file, physicsClientId=pid)

        # Start creature at height 10 to drop onto mountain
        p.resetBasePositionAndOrientation(cid, [0, 0, 10], [0, 0, 0, 1], physicsClientId=pid)

        for step in range(iterations):
            p.stepSimulation(physicsClientId=pid)
            if step % 24 == 0:
                self.update_motors(cid=cid, cr=cr)

            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            
            # Start tracking height after creature has landed (~1 second)
            if step >= 240:  # 240 steps = 1 second at 240fps
                cr.update_max_height(pos)

AFTER:
    def run_creature(self, cr, iterations=2400):
        pid = self.physicsClientId
        p.resetSimulation(physicsClientId=pid)
        p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)

        p.setGravity(0, 0, -10, physicsClientId=pid)
        
        # Create arena and mountain environment instead of flat plane
        arena_size = 20
        make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
        
        # Set search path for mountain URDF files
        p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
        
        # Load mountain
        mountain_position = (0, 0, -1)
        mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
        load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

        xml_file = 'temp' + str(self.sim_id) + '.urdf'
        xml_str = cr.to_xml()
        with open(xml_file, 'w') as f:
            f.write(xml_str)
        
        cid = p.loadURDF(xml_file, physicsClientId=pid)

        # Spawn creature at base of mountain (not dropped from height)
        # Mountain base is at z=-1, surface at center is ~z=0, spawn slightly above
        p.resetBasePositionAndOrientation(cid, [0, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

        # Phase 1: Brief settling period (120 steps = 0.5 seconds)
        for step in range(120):
            p.stepSimulation(physicsClientId=pid)
        
        # Reset max_height after settling to start tracking from settled position
        cr.max_height = 0
        
        # Phase 2: Main simulation with height tracking
        for step in range(120, iterations):
            p.stepSimulation(physicsClientId=pid)
            if step % 24 == 0:
                self.update_motors(cid=cid, cr=cr)

            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            cr.update_max_height(pos)  # Track absolute maximum Z-coordinate

---

LOCATION: realtime_from_csv.py, main function
BEFORE (lines ~13-30 and tracking section):
    pid = p.connect(p.GUI)
    p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)
    p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0, physicsClientId=pid)
    
    # Create arena and mountain environment
    p.setGravity(0, 0, -10, physicsClientId=pid)
    arena_size = 20
    
    # Import arena and mountain functions from simulation
    from simulation import make_arena, load_mountain
    make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
    
    # Set search path for mountain URDF files
    p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
    
    # Load mountain
    mountain_position = (0, 0, -1)
    mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
    load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

    # generate a random creature
    cr = creature.Creature(gene_count=1)
    dna = genome.Genome.from_csv(csv_file)
    cr.update_dna(dna)
    # save it to XML
    with open('test.urdf', 'w') as f:
        f.write(cr.to_xml())
    # load it into the sim
    rob1 = p.loadURDF('test.urdf', physicsClientId=pid)
    # air drop it
    p.resetBasePositionAndOrientation(rob1, [0, 0, 10], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
    pid = p.connect(p.GUI)
    p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)
    p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0, physicsClientId=pid)
    
    # Create arena and mountain environment
    p.setGravity(0, 0, -10, physicsClientId=pid)
    arena_size = 20
    
    # Import arena and mountain functions from simulation
    from simulation import make_arena, load_mountain
    make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
    
    # Set search path for mountain URDF files
    p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
    
    # Load mountain
    mountain_position = (0, 0, -1)
    mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
    load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

    # generate a random creature
    cr = creature.Creature(gene_count=1)
    dna = genome.Genome.from_csv(csv_file)
    cr.update_dna(dna)
    # save it to XML
    with open('test.urdf', 'w') as f:
        f.write(cr.to_xml())
    # load it into the sim
    rob1 = p.loadURDF('test.urdf', physicsClientId=pid)
    
    # Spawn at base of mountain (not dropped from height)
    p.resetBasePositionAndOrientation(rob1, [0, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)
    
    # Brief settling period
    for i in range(120):
        p.stepSimulation(physicsClientId=pid)

---

LOCATION: realtime_from_csv.py, tracking section in while loop
BEFORE (tracking logic in main loop):
    # Track height same way as training
    if step >= 240:  # After landing
        if baseline_height is None:
            baseline_height = new_pos[2]
            max_height = 0
        else:
            relative_height = new_pos[2] - baseline_height
            if relative_height > max_height:
                max_height = relative_height
        
        print(f"Current height: {new_pos[2]:.3f}, Max climb: {max_height:.3f}")

AFTER:
    # Track absolute maximum height (same as training)
    current_z = new_pos[2]
    if current_z > max_height:
        max_height = current_z
    
    print(f"Current Z: {current_z:.3f}, Max Z reached: {max_height:.3f}")

---

LOCATION: realtime_from_csv.py, variable initialization
BEFORE (around line ~48):
    max_height = 0
    baseline_height = None

AFTER:
    max_height = 0

---

LOCATION: realtime_from_csv.py, final print statement
BEFORE:
    print(f"\nFINAL MAX CLIMB HEIGHT: {max_height:.3f}")

AFTER:
    print(f"\nFINAL MAX HEIGHT REACHED: {max_height:.3f}")

================================================================================
END OF CHANGE #7
================================================================================