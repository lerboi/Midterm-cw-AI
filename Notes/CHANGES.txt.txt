================================================================================
                        COURSEWORK PART B - CHANGES LOG
                    Mountain Climbing Genetic Algorithm
================================================================================

This file documents ALL changes made to the original codebase to adapt it
for the mountain climbing task in Part B of the coursework.

Each entry contains:
1. HIGH-LEVEL SUMMARY - What was changed and why
2. FUNCTION-LEVEL DESCRIPTIONS - Which functions/methods were added/modified
3. LINE-BY-LINE CODE CHANGES - Actual code snippets showing modifications

================================================================================
CHANGE #1: Added Height Tracking to Creature Class
Date: 2024-12-14
File: creature.py
Reason: Need to track maximum height achieved for mountain climbing fitness
        instead of horizontal distance traveled
================================================================================

HIGH-LEVEL SUMMARY:
- Added max_height attribute to Creature class to track the highest z-coordinate
  reached during simulation
- Added method to update maximum height whenever creature position is updated
- Added method to retrieve final maximum height for fitness calculation
- Modified update_dna() to reset max_height when DNA is updated

FUNCTION-LEVEL CHANGES:

1. Modified __init__(self, gene_count)
   - Added: self.max_height = 0
   - Purpose: Initialize maximum height tracking at zero

2. Added update_max_height(self, pos)
   - New method to update max_height if current z-coordinate is higher
   - Called during simulation whenever position is updated
   
3. Added get_max_height(self)
   - New method to return the maximum height achieved
   - Used as fitness function for mountain climbing

4. Modified update_dna(self, dna)
   - Added: self.max_height = None
   - Purpose: Reset max_height when creature DNA is updated for next generation

LINE-BY-LINE CODE CHANGES:

LOCATION: creature.py, class Creature, __init__ method
BEFORE (line ~33):
        self.motors = None
        self.start_position = None
        self.last_position = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0  # NEW: Track maximum height for mountain climbing

---

LOCATION: creature.py, class Creature, new method after update_position
NEW METHOD ADDED (after line ~58):
    def update_max_height(self, pos):
        """
        Update the maximum height achieved by the creature.
        This is used for mountain climbing fitness.
        
        Args:
            pos: tuple of (x, y, z) coordinates
        """
        if pos is not None and len(pos) >= 3:
            current_height = pos[2]  # z-coordinate is height
            if current_height > self.max_height:
                self.max_height = current_height

---

LOCATION: creature.py, class Creature, new method after update_max_height
NEW METHOD ADDED:
    def get_max_height(self):
        """
        Get the maximum height achieved by the creature.
        Used as fitness function for mountain climbing.
        
        Returns:
            float: Maximum z-coordinate reached during simulation
        """
        return self.max_height

---

LOCATION: creature.py, class Creature, update_dna method
BEFORE (line ~68):
        self.motors = None
        self.start_position = None
        self.last_position = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0  # NEW: Reset max height for new DNA

================================================================================
END OF CHANGE #1
================================================================================


================================================================================
CHANGE #2: Modified Simulation for Mountain Climbing
Date: 2024-12-14
File: simulation.py (MODIFIED)
Reason: Need to replace flat plane environment with mountain terrain for
        mountain climbing task and track maximum height instead of distance
================================================================================

HIGH-LEVEL SUMMARY:
- Modified existing simulation.py file to support mountain climbing
- Replaced flat plane environment with arena + mountain setup from cw-envt.py
- Added helper functions to create arena walls and load mountain
- Modified run_creature() to track max height during simulation
- Modified run_creature() to call update_max_height() on creatures
- Set additional search path for loading mountain URDF files from shapes/ folder

FUNCTION-LEVEL CHANGES:

1. Added make_arena(arena_size, wall_height, physicsClientId)
   - New helper function at end of file
   - Creates sandbox arena with floor and four walls
   - Returns floor body ID
   
2. Added load_mountain(mountain_file, position, orientation, physicsClientId)
   - New helper function at end of file
   - Loads mountain URDF file from shapes/ directory
   - Returns mountain body ID

3. Modified run_creature(self, cr, iterations)
   - Replaced plane creation with arena + mountain setup
   - Added search path for shapes/ directory
   - Added call to cr.update_max_height(pos) during simulation loop
   - Changed starting position from [0, 0, 2.5] to [0, 0, 10]

4. Kept update_motors() unchanged
   - No changes needed for motor control

5. Kept eval_population() unchanged
   - No changes needed for population evaluation

6. ThreadedSim class kept unchanged
   - Works with the new simulation automatically

LINE-BY-LINE CODE CHANGES:

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (lines ~13-15):
        p.setGravity(0, 0, -10, physicsClientId=pid)
        plane_shape = p.createCollisionShape(p.GEOM_PLANE, physicsClientId=pid)
        floor = p.createMultiBody(plane_shape, plane_shape, physicsClientId=pid)

AFTER:
        p.setGravity(0, 0, -10, physicsClientId=pid)
        
        # Create arena and mountain environment instead of flat plane
        arena_size = 20
        make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
        
        # Set search path for mountain URDF files
        p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
        
        # Load mountain
        mountain_position = (0, 0, -1)
        mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
        load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

---

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (line ~23):
        p.resetBasePositionAndOrientation(cid, [0, 0, 2.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
        # Start creature at height 10 to drop onto mountain
        p.resetBasePositionAndOrientation(cid, [0, 0, 10], [0, 0, 0, 1], physicsClientId=pid)

---

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (lines ~30-33):
            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            #print(pos[2])
            #print(cr.get_distance_travelled())

AFTER:
            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            cr.update_max_height(pos)  # Track maximum height for mountain climbing

---

LOCATION: simulation.py, end of file (after ThreadedSim class)
NEW HELPER FUNCTIONS ADDED:

(See full code in next section)

================================================================================
END OF CHANGE #2
================================================================================


================================================================================
CHANGE #3: Created Mountain Climbing GA Test Script
Date: 2024-12-14
File: test_ga_mountain.py (NEW FILE)
Reason: Need a GA script that uses get_max_height() as fitness function instead
        of get_distance_travelled() for mountain climbing evolution
================================================================================

HIGH-LEVEL SUMMARY:
- Created new file test_ga_mountain.py based on test_ga_no_threads.py
- Modified fitness evaluation to use get_max_height() instead of get_distance_travelled()
- Changed elite creature filename to "elite_mountain_" prefix
- Kept same GA parameters (population size, gene count, mutation rates)
- Kept same structure: population creation, simulation, selection, crossover, mutation, elitism

FUNCTION-LEVEL CHANGES:

1. Modified testBasicGA() method
   - Changed fitness calculation from cr.get_distance_travelled() to cr.get_max_height()
   - Changed print statement to show "max height" instead of "fittest"
   - Changed elite filename from "elite_" to "elite_mountain_"
   - All other GA logic remains identical

2. No changes to:
   - Population creation (pop_size=10, gene_count=3)
   - Simulation setup (Simulation() class)
   - Selection process (get_fitness_map, select_parent)
   - Crossover and mutation (same rates)
   - Elitism implementation

LINE-BY-LINE CODE CHANGES:

LOCATION: test_ga_mountain.py (NEW FILE)
This is based on test_ga_no_threads.py with minimal changes.

BEFORE (from test_ga_no_threads.py, line ~23):
            fits = [cr.get_distance_travelled() 
                    for cr in pop.creatures]

AFTER:
            fits = [cr.get_max_height() 
                    for cr in pop.creatures]

---

BEFORE (from test_ga_no_threads.py, line ~27):
            print(iteration, "fittest:", np.round(np.max(fits), 3), 
                  "mean:", np.round(np.mean(fits), 3), "mean links", np.round(np.mean(links)), "max links", np.round(np.max(links)))

AFTER:
            print(iteration, "max height:", np.round(np.max(fits), 3), 
                  "mean:", np.round(np.mean(fits), 3), "mean links", np.round(np.mean(links)), "max links", np.round(np.max(links)))

---

BEFORE (from test_ga_no_threads.py, line ~44):
            max_fit = np.max(fits)
            for cr in pop.creatures:
                if cr.get_distance_travelled() == max_fit:
                    new_cr = creature.Creature(1)
                    new_cr.update_dna(cr.dna)
                    new_creatures[0] = new_cr
                    filename = "elite_"+str(iteration)+".csv"
                    genome.Genome.to_csv(cr.dna, filename)
                    break

AFTER:
            max_fit = np.max(fits)
            for cr in pop.creatures:
                if cr.get_max_height() == max_fit:
                    new_cr = creature.Creature(1)
                    new_cr.update_dna(cr.dna)
                    new_creatures[0] = new_cr
                    filename = "elite_mountain_"+str(iteration)+".csv"
                    genome.Genome.to_csv(cr.dna, filename)
                    break

================================================================================
END OF CHANGE #3
================================================================================


================================================================================
CHANGE #4: Created Parameter Experiment Scripts
Date: 2024-12-14
Files: experiment_population_size.py (NEW FILE)
       experiment_gene_count.py (NEW FILE)
       experiment_mutation_rates.py (NEW FILE)
Reason: Basic requirement - Need to test different GA and genome settings
        and collect data for graphs/tables showing how settings affect climbing
================================================================================

HIGH-LEVEL SUMMARY:
- Created three experiment scripts to test different GA parameters
- Each script runs the GA with different parameter values and saves results
- Results saved to CSV files in results/ folder for later analysis
- Data includes: generation number, max fitness, mean fitness, max links, mean links
- Scripts based on test_ga_mountain.py with data collection added

EXPERIMENT SCRIPTS:

1. experiment_population_size.py
   - Tests population sizes: 5, 10, 20, 50
   - Gene count fixed at 3
   - Runs 500 generations for each population size
   - Saves results to: results/pop_size_{size}.csv

2. experiment_gene_count.py
   - Tests gene counts: 2, 3, 5, 10
   - Population size fixed at 10
   - Runs 500 generations for each gene count
   - Saves results to: results/gene_count_{count}.csv

3. experiment_mutation_rates.py
   - Tests different mutation rate combinations
   - Population size fixed at 10, gene count fixed at 3
   - Runs 500 generations for each rate combination
   - Saves results to: results/mutation_point_{rate}_shrink_{rate}_grow_{rate}.csv
   - Tests:
     * Low rates: point=0.05, shrink=0.1, grow=0.05
     * Medium rates: point=0.1, shrink=0.25, grow=0.1 (baseline)
     * High rates: point=0.25, shrink=0.5, grow=0.25

FUNCTION-LEVEL CHANGES:

1. Added save_results() helper function
   - Saves generation data to CSV file
   - Creates results/ directory if it doesn't exist
   - Appends data row by row during evolution

2. Modified testBasicGA() in each experiment
   - Loops through different parameter values
   - Collects fitness and link statistics each generation
   - Saves data to CSV files
   - Prints progress to console

3. Added data collection during GA loop
   - Records: iteration, max_fit, mean_fit, max_links, mean_links
   - Saves elite creature DNA to elite_creatures/ folder

LINE-BY-LINE CODE CHANGES:

All three files are new, based on test_ga_mountain.py with these additions:

NEW HELPER FUNCTION (added to all experiment scripts):
def save_results(filename, generation, max_fit, mean_fit, max_links, mean_links):
    """Save experiment results to CSV file"""
    import os
    os.makedirs("results", exist_ok=True)
    filepath = os.path.join("results", filename)
    
    # Create file with headers if it doesn't exist
    if not os.path.exists(filepath):
        with open(filepath, 'w') as f:
            f.write("generation,max_fitness,mean_fitness,max_links,mean_links\n")
    
    # Append data
    with open(filepath, 'a') as f:
        f.write(f"{generation},{max_fit},{mean_fit},{max_links},{mean_links}\n")

MODIFIED GA LOOP (example from experiment_population_size.py):
for pop_size in [5, 10, 20, 50]:
    print(f"\n{'='*60}")
    print(f"Testing Population Size: {pop_size}")
    print(f"{'='*60}\n")
    
    pop = population.Population(pop_size=pop_size, gene_count=3)
    sim = simulation.Simulation()
    
    for iteration in range(500):
        # ... GA loop ...
        
        # Save results after each generation
        save_results(
            f"pop_size_{pop_size}.csv",
            iteration,
            np.max(fits),
            np.mean(fits),
            np.max(links),
            np.mean(links)
        )

================================================================================
END OF CHANGE #4
================================================================================


================================================================================
CHANGE #5: Created Visualization Script for Graphs and Tables
Date: 2024-12-14
File: create_graphs.py (NEW FILE)
Reason: Basic requirement - Need to produce graphs and tables describing how
        different settings affect mountain climbing performance
================================================================================

HIGH-LEVEL SUMMARY:
- Created visualization script to analyze experimental results
- Generates line graphs showing fitness over generations for each parameter
- Creates comparison plots showing all configurations on same graph
- Produces summary tables with key statistics
- Saves all outputs to graphs/ folder

FEATURES:

1. Line Graphs for Each Experiment
   - Population size experiments: 4 separate graphs
   - Gene count experiments: 4 separate graphs
   - Mutation rate experiments: 3 separate graphs
   - Shows max fitness and mean fitness over time

2. Comparison Plots
   - All population sizes on one graph
   - All gene counts on one graph
   - All mutation configurations on one graph
   - Easy visual comparison of different settings

3. Summary Tables
   - Creates CSV files with statistics for each experiment
   - Includes: final max fitness, final mean fitness, peak generation
   - Saved to graphs/summary_*.csv

FUNCTION-LEVEL CHANGES:

1. plot_single_experiment(csv_file, title, output_file)
   - Reads CSV data from results/ folder
   - Creates line plot with max and mean fitness
   - Saves to graphs/ folder

2. plot_comparison(csv_files, labels, title, output_file)
   - Plots multiple experiments on same graph
   - Different colors for each configuration
   - Includes legend for identification

3. create_summary_table(csv_files, labels, output_file)
   - Analyzes final results from each experiment
   - Creates summary statistics table
   - Saves to CSV for inclusion in report

4. main()
   - Orchestrates all visualization tasks
   - Calls plotting functions for each experiment type
   - Creates all graphs and tables

LINE-BY-LINE CODE CHANGES:

LOCATION: create_graphs.py (NEW FILE)
This is a completely new file.

Key libraries used:
- matplotlib.pyplot for plotting
- pandas for data handling
- numpy for statistics

Output structure:
- graphs/pop_size_*.png (individual plots)
- graphs/pop_size_comparison.png (comparison plot)
- graphs/gene_count_*.png (individual plots)
- graphs/gene_count_comparison.png (comparison plot)
- graphs/mutation_*.png (individual plots)
- graphs/mutation_comparison.png (comparison plot)
- graphs/summary_population.csv (statistics table)
- graphs/summary_genes.csv (statistics table)
- graphs/summary_mutation.csv (statistics table)

================================================================================
END OF CHANGE #5
================================================================================


================================================================================
CHANGE #6: Reorganized Experiments and Created Main Orchestrator Script
Date: 2024-12-14
Files: experiments/experiment_population_size.py (MOVED & MODIFIED)
       experiments/experiment_gene_count.py (MOVED & MODIFIED)
       experiments/experiment_mutation_rates.py (MOVED & MODIFIED)
       experiments/create_graphs.py (MOVED & MODIFIED)
       run_all_experiments.py (NEW FILE - ROOT)
Reason: Organize experiment files and create single script to run all
        experiments and generate graphs automatically
================================================================================

HIGH-LEVEL SUMMARY:
- Created experiments/ folder to organize all experiment and visualization scripts
- Moved all experiment scripts into experiments/ folder
- Modified experiment scripts to be both standalone runnable AND importable
- Modified create_graphs.py to auto-display graphs and be importable
- Created run_all_experiments.py as main orchestrator in root folder
- Updated all file paths to work with new folder structure

FOLDER STRUCTURE:
experiments/
  ├── experiment_population_size.py
  ├── experiment_gene_count.py
  ├── experiment_mutation_rates.py
  └── create_graphs.py

root/
  └── run_all_experiments.py (NEW)

results/ (created automatically)
graphs/ (created automatically)
elite_creatures/ (created automatically)

MODIFICATIONS TO EXPERIMENT SCRIPTS:

1. Added run_population_experiments() function
   - Extracted logic from testPopulationSizes()
   - Can be called from external scripts
   - Returns nothing, saves results to CSV

2. Modified file paths
   - Changed "results/" to "../results/" (parent directory)
   - Changed "elite_creatures/" to "../elite_creatures/"

3. Wrapped unittest.main() in if __name__ == "__main__"
   - Allows standalone execution
   - Prevents auto-run when imported

MODIFICATIONS TO CREATE_GRAPHS.PY:

1. Added generate_all_graphs() function
   - Wrapper for main() function
   - Can be called from external scripts

2. Added display_comparison_graphs() function
   - Opens comparison plots with plt.show()
   - Displays graphs in popup windows

3. Modified file paths
   - Changed "results/" to "../results/"
   - Changed "graphs/" to "../graphs/"

4. Modified plotting functions
   - Auto-display graphs after saving
   - Use plt.show() for comparison plots

NEW RUN_ALL_EXPERIMENTS.PY:

1. Main orchestrator script
   - Imports experiment modules
   - Runs all experiments sequentially
   - Generates graphs automatically
   - Displays comparison graphs

2. Features
   - Simple text progress output
   - Error handling for each step
   - Clear completion messages

LINE-BY-LINE CODE CHANGES:

LOCATION: experiments/experiment_population_size.py
ADDED NEW FUNCTION (before class TestGA):

def run_population_experiments():
    """Run population size experiments - callable from other scripts"""
    # ... (extracted from testPopulationSizes)

MODIFIED: File paths
BEFORE: "results/pop_size_{pop_size}.csv"
AFTER: "../results/pop_size_{pop_size}.csv"

BEFORE: "elite_creatures/pop_{pop_size}_gen_{iteration}.csv"
AFTER: "../elite_creatures/pop_{pop_size}_gen_{iteration}.csv"

MODIFIED: unittest.main() call
BEFORE (at end of file):
unittest.main()

AFTER:
if __name__ == "__main__":
    unittest.main()

---

SIMILAR CHANGES FOR:
- experiments/experiment_gene_count.py (added run_gene_experiments())
- experiments/experiment_mutation_rates.py (added run_mutation_experiments())

---

LOCATION: experiments/create_graphs.py
ADDED NEW FUNCTIONS:

def generate_all_graphs():
    """Generate all graphs - callable from other scripts"""
    main()

def display_comparison_graphs():
    """Display comparison graphs in popup windows"""
    # Opens the 3 main comparison plots

MODIFIED: All file paths
BEFORE: "results/"
AFTER: "../results/"

BEFORE: "graphs/"
AFTER: "../graphs/"

MODIFIED: plot_comparison() function
ADDED at end: plt.show() to display graph

---

LOCATION: run_all_experiments.py (NEW FILE IN ROOT)
Complete new orchestrator script that:
1. Runs all experiments
2. Generates graphs
3. Displays results

================================================================================
END OF CHANGE #6
================================================================================


================================================================================
CHANGE #7: Fixed Fitness Function to Track Absolute Maximum Height
Date: 2024-12-14
Files: creature.py (MODIFIED)
       simulation.py (MODIFIED)
       realtime_from_csv.py (MODIFIED)
Reason: Fix incorrect fitness calculation - should track absolute maximum
        Z-coordinate (closeness to mountain peak), not relative climb from
        random landing position
================================================================================

HIGH-LEVEL SUMMARY:
- Removed baseline height tracking that was causing incorrect fitness
- Changed spawning from z=10 (drop) to z=0.5 (base of mountain)
- Implemented two-phase simulation: settling + tracking
- Fitness now measures absolute maximum height reached (correct per PDF)
- All creatures start from same position (fair comparison)

PROBLEM IDENTIFIED:
Previous implementation tracked height relative to landing position:
- Creatures dropped from z=10 with random bouncing
- Baseline set to wherever creature landed (inconsistent)
- Fitness = relative climb from baseline (wrong metric)
- Rewarded "landing low + small climb" over "reaching actual peak"
- Caused creatures to grow larger instead of learning to climb

SOLUTION IMPLEMENTED:
New implementation tracks absolute maximum Z-coordinate:
- Creatures spawn at mountain base z=0.5 (consistent start)
- Brief settling period (0.5 seconds)
- Track absolute max Z during simulation
- Fitness = highest Z-coordinate reached (correct per PDF requirement)
- Directly measures "maximum closeness to top of mountain"

FUNCTION-LEVEL CHANGES:

1. creature.py - Removed baseline tracking
   - Removed self.baseline_height attribute from __init__
   - Simplified update_max_height() to track absolute max Z only
   - Removed baseline from update_dna()

2. simulation.py - Changed spawn position and tracking
   - Changed spawn from z=10 to z=0.5 (mountain base)
   - Added two-phase simulation (settling + tracking)
   - Reset max_height to 0 after settling phase
   - Track absolute height throughout main simulation

3. realtime_from_csv.py - Same fixes for playback
   - Changed spawn from z=10 to z=0.5
   - Removed baseline tracking
   - Display absolute Z-coordinates

LINE-BY-LINE CODE CHANGES:

LOCATION: creature.py, class Creature, __init__ method
BEFORE (line ~33):
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0
        self.baseline_height = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0

---

LOCATION: creature.py, class Creature, update_max_height method
BEFORE (entire method):
    def update_max_height(self, pos):
        """
        Update the maximum height achieved by the creature.
        This is used for mountain climbing fitness.
        
        Args:
            pos: tuple of (x, y, z) coordinates
        """
        if pos is not None and len(pos) >= 3:
            # Set baseline on first call (where creature landed)
            if self.baseline_height is None:
                self.baseline_height = pos[2]
                self.max_height = 0  # Start from 0 relative to landing
            else:
                # Track height relative to baseline (landing position)
                relative_height = pos[2] - self.baseline_height
                if relative_height > self.max_height:
                    self.max_height = relative_height

AFTER:
    def update_max_height(self, pos):
        """
        Update the maximum height achieved by the creature.
        Tracks absolute maximum Z-coordinate for mountain climbing fitness.
        
        Args:
            pos: tuple of (x, y, z) coordinates
        """
        if pos is not None and len(pos) >= 3:
            current_height = pos[2]  # Absolute Z-coordinate
            if current_height > self.max_height:
                self.max_height = current_height

---

LOCATION: creature.py, class Creature, update_dna method
BEFORE (line ~68):
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0
        self.baseline_height = None

AFTER:
        self.motors = None
        self.start_position = None
        self.last_position = None
        self.max_height = 0

---

LOCATION: simulation.py, class Simulation, run_creature method
BEFORE (entire method - line ~10-43):
    def run_creature(self, cr, iterations=2400):
        pid = self.physicsClientId
        p.resetSimulation(physicsClientId=pid)
        p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)

        p.setGravity(0, 0, -10, physicsClientId=pid)
        
        # Create arena and mountain environment instead of flat plane
        arena_size = 20
        make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
        
        # Set search path for mountain URDF files
        p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
        
        # Load mountain
        mountain_position = (0, 0, -1)
        mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
        load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

        xml_file = 'temp' + str(self.sim_id) + '.urdf'
        xml_str = cr.to_xml()
        with open(xml_file, 'w') as f:
            f.write(xml_str)
        
        cid = p.loadURDF(xml_file, physicsClientId=pid)

        # Start creature at height 10 to drop onto mountain
        p.resetBasePositionAndOrientation(cid, [0, 0, 10], [0, 0, 0, 1], physicsClientId=pid)

        for step in range(iterations):
            p.stepSimulation(physicsClientId=pid)
            if step % 24 == 0:
                self.update_motors(cid=cid, cr=cr)

            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            
            # Start tracking height after creature has landed (~1 second)
            if step >= 240:  # 240 steps = 1 second at 240fps
                cr.update_max_height(pos)

AFTER:
    def run_creature(self, cr, iterations=2400):
        pid = self.physicsClientId
        p.resetSimulation(physicsClientId=pid)
        p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)

        p.setGravity(0, 0, -10, physicsClientId=pid)
        
        # Create arena and mountain environment instead of flat plane
        arena_size = 20
        make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
        
        # Set search path for mountain URDF files
        p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
        
        # Load mountain
        mountain_position = (0, 0, -1)
        mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
        load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

        xml_file = 'temp' + str(self.sim_id) + '.urdf'
        xml_str = cr.to_xml()
        with open(xml_file, 'w') as f:
            f.write(xml_str)
        
        cid = p.loadURDF(xml_file, physicsClientId=pid)

        # Spawn creature at base of mountain (not dropped from height)
        # Mountain base is at z=-1, surface at center is ~z=0, spawn slightly above
        p.resetBasePositionAndOrientation(cid, [0, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

        # Phase 1: Brief settling period (120 steps = 0.5 seconds)
        for step in range(120):
            p.stepSimulation(physicsClientId=pid)
        
        # Reset max_height after settling to start tracking from settled position
        cr.max_height = 0
        
        # Phase 2: Main simulation with height tracking
        for step in range(120, iterations):
            p.stepSimulation(physicsClientId=pid)
            if step % 24 == 0:
                self.update_motors(cid=cid, cr=cr)

            pos, orn = p.getBasePositionAndOrientation(cid, physicsClientId=pid)
            cr.update_position(pos)
            cr.update_max_height(pos)  # Track absolute maximum Z-coordinate

---

LOCATION: realtime_from_csv.py, main function
BEFORE (lines ~13-30 and tracking section):
    pid = p.connect(p.GUI)
    p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)
    p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0, physicsClientId=pid)
    
    # Create arena and mountain environment
    p.setGravity(0, 0, -10, physicsClientId=pid)
    arena_size = 20
    
    # Import arena and mountain functions from simulation
    from simulation import make_arena, load_mountain
    make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
    
    # Set search path for mountain URDF files
    p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
    
    # Load mountain
    mountain_position = (0, 0, -1)
    mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
    load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

    # generate a random creature
    cr = creature.Creature(gene_count=1)
    dna = genome.Genome.from_csv(csv_file)
    cr.update_dna(dna)
    # save it to XML
    with open('test.urdf', 'w') as f:
        f.write(cr.to_xml())
    # load it into the sim
    rob1 = p.loadURDF('test.urdf', physicsClientId=pid)
    # air drop it
    p.resetBasePositionAndOrientation(rob1, [0, 0, 10], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
    pid = p.connect(p.GUI)
    p.setPhysicsEngineParameter(enableFileCaching=0, physicsClientId=pid)
    p.configureDebugVisualizer(p.COV_ENABLE_GUI, 0, physicsClientId=pid)
    
    # Create arena and mountain environment
    p.setGravity(0, 0, -10, physicsClientId=pid)
    arena_size = 20
    
    # Import arena and mountain functions from simulation
    from simulation import make_arena, load_mountain
    make_arena(arena_size=arena_size, wall_height=1, physicsClientId=pid)
    
    # Set search path for mountain URDF files
    p.setAdditionalSearchPath('shapes/', physicsClientId=pid)
    
    # Load mountain
    mountain_position = (0, 0, -1)
    mountain_orientation = p.getQuaternionFromEuler((0, 0, 0))
    load_mountain("gaussian_pyramid.urdf", mountain_position, mountain_orientation, physicsClientId=pid)

    # generate a random creature
    cr = creature.Creature(gene_count=1)
    dna = genome.Genome.from_csv(csv_file)
    cr.update_dna(dna)
    # save it to XML
    with open('test.urdf', 'w') as f:
        f.write(cr.to_xml())
    # load it into the sim
    rob1 = p.loadURDF('test.urdf', physicsClientId=pid)
    
    # Spawn at base of mountain (not dropped from height)
    p.resetBasePositionAndOrientation(rob1, [0, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)
    
    # Brief settling period
    for i in range(120):
        p.stepSimulation(physicsClientId=pid)

---

LOCATION: realtime_from_csv.py, tracking section in while loop
BEFORE (tracking logic in main loop):
    # Track height same way as training
    if step >= 240:  # After landing
        if baseline_height is None:
            baseline_height = new_pos[2]
            max_height = 0
        else:
            relative_height = new_pos[2] - baseline_height
            if relative_height > max_height:
                max_height = relative_height
        
        print(f"Current height: {new_pos[2]:.3f}, Max climb: {max_height:.3f}")

AFTER:
    # Track absolute maximum height (same as training)
    current_z = new_pos[2]
    if current_z > max_height:
        max_height = current_z
    
    print(f"Current Z: {current_z:.3f}, Max Z reached: {max_height:.3f}")

---

LOCATION: realtime_from_csv.py, variable initialization
BEFORE (around line ~48):
    max_height = 0
    baseline_height = None

AFTER:
    max_height = 0

---

LOCATION: realtime_from_csv.py, final print statement
BEFORE:
    print(f"\nFINAL MAX CLIMB HEIGHT: {max_height:.3f}")

AFTER:
    print(f"\nFINAL MAX HEIGHT REACHED: {max_height:.3f}")

================================================================================
END OF CHANGE #7
================================================================================


================================================================================
CHANGE #8: Fixed Spawn Position to Mountain Base/Edge
Date: 2024-12-15
Files: simulation.py (MODIFIED)
       realtime_from_csv.py (MODIFIED)
Reason: Creatures were spawning inside mountain at center (0,0). Need to spawn
        at edge/base of mountain on flat floor so creatures must move toward
        center and climb up the slope.
================================================================================

HIGH-LEVEL SUMMARY:
- Changed spawn position from (0, 0, 1.5) to (5, 0, 0.5)
- Creatures now spawn at mountain base/edge on flat floor
- Must move horizontally toward center (0,0) where mountain peak is
- Then climb vertically up the slope
- Prevents spawning inside mountain geometry

PROBLEM IDENTIFIED:
- Mountain is centered at (0, 0) with peak at z≈4
- Previous spawn at (0, 0, 1.5) placed creatures inside mountain
- Creatures clipped through geometry or got stuck
- No need to navigate toward mountain

SOLUTION IMPLEMENTED:
- Spawn at (5, 0, 0.5) - at edge of mountain on flat floor
- X=5: Just outside mountain radius (~3-4 units), on flat arena floor
- Y=0: Along axis for simple path to center
- Z=0.5: Slightly above floor to prevent clipping
- Creatures must move toward (0,0) to encounter slope and climb

FUNCTION-LEVEL CHANGES:

1. simulation.py - Updated spawn position in run_creature()
   - Changed from (0, 0, 1.5) to (5, 0, 0.5)
   - Updated comment to clarify spawn location

2. realtime_from_csv.py - Updated spawn position
   - Changed from (0, 0, 1.5) to (5, 0, 0.5)
   - Updated comment to clarify spawn location

LINE-BY-LINE CODE CHANGES:

LOCATION: simulation.py, run_creature method
BEFORE:
        # Spawn creature at base of mountain (not dropped from height)
        # Mountain base is at z=-1, but surface rises, spawn at z=1.5 to be above surface
        p.resetBasePositionAndOrientation(cid, [0, 0, 1.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
        # Spawn creature at edge of mountain on flat floor
        # Mountain centered at (0,0), spawn at (5,0,0.5) - edge/base on flat floor
        # Creature must move toward center to climb mountain
        p.resetBasePositionAndOrientation(cid, [5, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

---

LOCATION: realtime_from_csv.py, main function
BEFORE:
    # Spawn at base of mountain (not dropped from height)
    p.resetBasePositionAndOrientation(rob1, [0, 0, 1.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
    # Spawn at edge of mountain on flat floor
    # Mountain centered at (0,0), spawn at (5,0,0.5) - must move toward center to climb
    p.resetBasePositionAndOrientation(rob1, [5, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

================================================================================
END OF CHANGE #8
================================================================================


================================================================================
CHANGE #9: Arena Size Increase, Spawn Position Fix, and Creature Size Reduction
Date: 2024-12-15
Files: simulation.py (MODIFIED)
       realtime_from_csv.py (MODIFIED)
       genome.py (MODIFIED)
Reason: (1) Increase yellow floor space and gap between walls and mountain
        (2) Fix spawn position to verified mountain base location
        (3) Reduce creature size by half for better proportions relative to mountain
================================================================================

HIGH-LEVEL SUMMARY:
- Increased arena size from 20 to 40 units (double the floor space)
- Fixed spawn position to [-5.3, 0, 0.5] (verified mountain base location)
- Reduced creature size by half (link-length scale: 2→1, link-radius: 1→0.5)
- More visible yellow floor, better spacing, correctly positioned creatures
- Creatures now appropriately sized relative to 10-unit mountain

PROBLEM IDENTIFIED:
Multiple issues needed fixing:
1. Arena too small (20x20) - mountain occupies 50% of floor space
2. Spawn position incorrect - creatures spawning inside mountain geometry
3. Creatures too large - 20-30% of mountain size, disproportionate

SOLUTION IMPLEMENTED:
1. Arena Size: 20 → 40
   - Floor now 40x40 units instead of 20x20
   - Mountain still 10x10 (unchanged)
   - Gap between mountain edge (±5) and walls (±20) now 15 units instead of 5
   - Much more visible yellow floor space

2. Spawn Position: Various → [-5.3, 0, 0.5]
   - Verified position at mountain base on flat floor
   - Negative X side of mountain (left side)
   - Creatures must move toward center (0,0) in +X direction
   - No directional bias added - evolution discovers movement naturally

3. Creature Size: Reduced by 50%
   - link-length scale: 2 → 1 (max length now 1 unit instead of 2)
   - link-radius scale: 1 → 0.5 (max radius now 0.5 units instead of 1)
   - Creatures now 1-1.5 units total size vs previous 2-3 units
   - Better proportioned relative to 10-unit wide mountain

FUNCTION-LEVEL CHANGES:

1. simulation.py - Updated arena size and spawn position in run_creature()
   - Changed arena_size from 20 to 40
   - Changed spawn from [5, 0, 0.5] to [-5.3, 0, 0.5]

2. realtime_from_csv.py - Updated arena size and spawn position
   - Changed arena_size from 20 to 40
   - Changed spawn from [0.7, 0, 0.5] to [-5.3, 0, 0.5]

3. genome.py - Reduced gene scales in get_gene_spec()
   - link-length scale: 2 → 1
   - link-radius scale: 1 → 0.5

LINE-BY-LINE CODE CHANGES:

LOCATION: simulation.py, run_creature method, line ~13
BEFORE:
        arena_size = 20

AFTER:
        arena_size = 40

---

LOCATION: simulation.py, run_creature method, line ~29
BEFORE:
        # Spawn creature at edge of mountain on flat floor
        # Mountain centered at (0,0), spawn at (5,0,0.5) - edge/base on flat floor
        # Creature must move toward center to climb mountain
        p.resetBasePositionAndOrientation(cid, [5, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
        # Spawn creature at mountain base on flat floor
        # Mountain centered at (0,0), spawn at (-5.3,0,0.5) - at base of slope
        # Creature must move toward center (+X direction) to climb mountain
        p.resetBasePositionAndOrientation(cid, [-5.3, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

---

LOCATION: realtime_from_csv.py, main function, line ~20
BEFORE:
    arena_size = 20

AFTER:
    arena_size = 40

---

LOCATION: realtime_from_csv.py, main function, line ~45
BEFORE:
    # Spawn at edge of mountain on flat floor
    # Mountain centered at (0,0), spawn at (5,0,0.5) - must move toward center to climb
    p.resetBasePositionAndOrientation(rob1, [0.7, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
    # Spawn at mountain base on flat floor
    # Mountain centered at (0,0), spawn at (-5.3,0,0.5) - at base of slope
    p.resetBasePositionAndOrientation(rob1, [-5.3, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

---

LOCATION: genome.py, get_gene_spec method
BEFORE:
        gene_spec =  {"link-shape":{"scale":1}, 
            "link-length": {"scale":2},
            "link-radius": {"scale":1},

AFTER:
        gene_spec =  {"link-shape":{"scale":1}, 
            "link-length": {"scale":1},
            "link-radius": {"scale":0.5},

================================================================================
END OF CHANGE #9
================================================================================


================================================================================
CHANGE #10: Mountain Enlargement and Climbability Improvements
Date: 2024-12-15
Files: shapes/gaussian_pyramid.obj (REGENERATED)
       simulation.py (MODIFIED)
       realtime_from_csv.py (MODIFIED)
       prepare_shapes.py (USED TO REGENERATE)
Reason: Make mountain more climbable with gentler slope and more texture,
        increase size to 15x15 base for more impressive visual presence
================================================================================

HIGH-LEVEL SUMMARY:
- Regenerated mountain mesh with larger base (10x10 → 15x15)
- Increased height (5 units → 6 units, 20% taller)
- Made slope gentler (sigma: 3 → 5) for easier climbing
- Added more texture/grip (noise factor: 1.0 → 0.8) for better traction
- Updated spawn positions to match new mountain edge at -7.5
- Mountain now more visually impressive and easier to climb

PROBLEM IDENTIFIED:
Previous mountain was:
- Too small (10x10) relative to 40x40 arena
- Too steep near edges (hard for creatures to climb)
- Smooth surface (less grip/traction)
- Not challenging/impressive enough

SOLUTION IMPLEMENTED:
New mountain parameters:
- Base size: 15x15 units (50% larger)
- Height: 6 units (20% taller than previous 5)
- Sigma: 5 (gentler slope - was 3)
- Noise scale: 0.3 (more variation)
- Noise factor: 0.8 (more texture for grip - was 1.0)
- Mountain edges now at ±7.5 instead of ±5

Benefits:
- Gentler slope = easier for creatures to make progress
- More texture = better grip/traction points
- Larger size = more impressive visually
- Taller = more challenging overall
- Still fits well in 40x40 arena (37.5% coverage vs 25%)

FUNCTION-LEVEL CHANGES:

1. prepare_shapes.py - Modified generation function
   - Created generate_gaussian_pyramid_climbable() function
   - Parameters: size=15, height=6, sigma=5, noise_scale=0.3, noise_factor=0.8

2. gaussian_pyramid.obj - Completely regenerated
   - New vertices spanning x,y: -7.5 to 7.5 (was -5 to 5)
   - Peak at approximately z=6 (was z=5)
   - Gentler slope profile throughout
   - More surface texture from Perlin noise

3. simulation.py - Updated spawn position
   - Changed from [-5.3, 0, 0.5] to [-7.8, 0, 0.5]
   - Now at edge of new larger mountain

4. realtime_from_csv.py - Updated spawn position
   - Changed from [-5.3, 0, 0.5] to [-7.8, 0, 0.5]
   - Matches training spawn position

LINE-BY-LINE CODE CHANGES:

LOCATION: simulation.py, run_creature method, spawn position
BEFORE:
        # Spawn creature at mountain base on flat floor
        # Mountain centered at (0,0), spawn at (-5.3,0,0.5) - at base of slope
        # Creature must move toward center (+X direction) to climb mountain
        p.resetBasePositionAndOrientation(cid, [-5.3, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
        # Spawn creature at mountain base on flat floor
        # Mountain centered at (0,0), spawn at (-7.8,0,0.5) - at base of slope
        # Creature must move toward center (+X direction) to climb mountain
        # Mountain now 15x15 with edges at ±7.5
        p.resetBasePositionAndOrientation(cid, [-7.8, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

---

LOCATION: realtime_from_csv.py, main function, spawn position
BEFORE:
    # Spawn at mountain base on flat floor
    # Mountain centered at (0,0), spawn at (-5.3,0,0.5) - at base of slope
    p.resetBasePositionAndOrientation(rob1, [-5.3, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

AFTER:
    # Spawn at mountain base on flat floor
    # Mountain centered at (0,0), spawn at (-7.8,0,0.5) - at base of slope
    # Mountain now 15x15 with edges at ±7.5
    p.resetBasePositionAndOrientation(rob1, [-7.8, 0, 0.5], [0, 0, 0, 1], physicsClientId=pid)

---

MOUNTAIN GENERATION PARAMETERS:
Used in prepare_shapes.py to regenerate gaussian_pyramid.obj:

def generate_gaussian_pyramid_climbable(
    filename, 
    size=15,              # Base size (was 10)
    resolution=0.5,       # Mesh resolution (unchanged)
    sigma=5,              # Slope gentleness (was 3)
    height=6,             # Peak height (was 5)
    noise_scale=0.3,      # Texture detail (was 0.5)
    noise_factor=0.8      # Texture intensity (was 1.0)
)

Gaussian function: height * exp(-((x² + y²) / (2 * sigma²)))
- Larger sigma = gentler slope
- sigma=5 vs sigma=3 = ~40% gentler slope gradient

WORLD COORDINATES:
After loading at position (0, 0, -1):
- Mountain base (flat): z = -1
- Mountain edges (±7.5, 0): z ≈ 0.8 to 2.0
- Mountain mid-radius (±3.75, 0): z ≈ 3.5 to 4.5
- Mountain peak (0, 0): z ≈ 5.0 (6 - 1)

Creature spawn at (-7.8, 0, 0.5):
- Just beyond mountain edge
- On arena floor
- 0.3 units from mountain base slope

================================================================================
END OF CHANGE #10
================================================================================