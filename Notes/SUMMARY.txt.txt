================================================================================
                    CM3020 AI COURSEWORK - PART B SUMMARY
                    A Beginner-Friendly Explanation
================================================================================

TABLE OF CONTENTS:
1. What is this coursework about?
2. What is a Genetic Algorithm?
3. What are these "creatures"?
4. What was the ORIGINAL task?
5. What is the NEW task (Part B)?
6. How does the whole system work step-by-step?
7. What do I need to do for Part B?
8. Simple analogy to understand everything

================================================================================
1. WHAT IS THIS COURSEWORK ABOUT?
================================================================================

Imagine you want to create robots that can move around and accomplish tasks,
but you don't want to manually design them. Instead, you want the computer to
"evolve" better and better robots automatically, similar to how animals evolved
in nature over millions of years.

This coursework is about using EVOLUTION and NATURAL SELECTION (concepts from
biology) to automatically design robots that can climb a mountain in a 
simulated 3D physics world.

================================================================================
2. WHAT IS A GENETIC ALGORITHM?
================================================================================

A Genetic Algorithm (GA) is a computer program inspired by biological evolution.
Here's how it works in simple terms:

STEP 1 - CREATE RANDOM POPULATION:
   - Start with a bunch of random "creatures" (robots)
   - Each creature is different (different body shapes, different movements)
   - Most of them will be terrible at the task!

STEP 2 - TEST EACH CREATURE:
   - Put each creature in a physics simulation
   - See how well it performs (this is called "fitness")
   - Example: "Did it move forward? Did it climb high?"

STEP 3 - SELECT THE BEST ONES:
   - The creatures that performed best get to "reproduce"
   - The worst creatures "die off" and don't get to have children
   - This is natural selection!

STEP 4 - CREATE NEXT GENERATION:
   - Take the best creatures and combine their "DNA" to make children
   - Add some random mutations (small random changes)
   - This creates a new generation of creatures

STEP 5 - REPEAT:
   - Test the new generation
   - Select the best ones again
   - Create another generation
   - Keep doing this for hundreds of generations

RESULT:
   After many generations, the creatures get better and better at the task!
   They "evolve" to be good climbers without anyone explicitly programming
   how to climb.

================================================================================
3. WHAT ARE THESE "CREATURES"?
================================================================================

The creatures are simulated robots made of:

BODY PARTS (called "links"):
   - Cylindrical segments (like robot limbs or body segments)
   - Each segment has properties: length, radius, mass
   - Segments can be connected to each other

JOINTS (connections between body parts):
   - Connect one body part to another
   - Can rotate (like your elbow or knee)
   - Have motors that make them move

MOTORS (what makes the creature move):
   - Control the joints
   - Can move in different patterns:
     * PULSE: on-off-on-off (like a piston)
     * SINE: smooth wave motion (like swimming)
   - Each motor has: frequency (how fast), amplitude (how strong)

DNA (genetic code):
   - Each creature has "DNA" - a list of numbers
   - These numbers encode EVERYTHING about the creature:
     * How many body parts it has
     * What size/shape each part is
     * How the parts connect together
     * How the motors move
   - When two creatures "reproduce", their DNA combines
   - Mutations randomly change some numbers in the DNA

EXAMPLE:
   Imagine a creature that evolved to have:
   - A main body cylinder
   - Four leg-like appendages
   - Motors that pulse in a coordinated way to "walk"
   - This design emerged through evolution, not manual programming!

================================================================================
4. WHAT WAS THE ORIGINAL TASK?
================================================================================

In the original Genetic Algorithm case study, creatures were trying to:

TASK: Move as far as possible across a FLAT GROUND

ENVIRONMENT:
   - Flat plane (like a floor)
   - Gravity pulling creatures down
   - Physics simulation (creatures can fall, slide, roll)

FITNESS FUNCTION (how we measure success):
   - Measure the DISTANCE the creature traveled
   - Start position: (0, 0, 0)
   - End position: wherever it ended up after simulation
   - Fitness = distance between start and end
   - Higher distance = better fitness = more likely to reproduce

WHAT EVOLVED:
   - Creatures that could crawl, walk, roll, or wiggle across the ground
   - Different body shapes emerged: snake-like, spider-like, worm-like
   - The GA discovered movement strategies automatically!

================================================================================
5. WHAT IS THE NEW TASK (PART B)?
================================================================================

Part B changes the environment and the goal:

NEW TASK: Climb as HIGH as possible up a MOUNTAIN

NEW ENVIRONMENT:
   - A sandbox arena (like a box with walls)
   - A mountain in the middle of the arena
   - The mountain is a 3D shape (Gaussian pyramid - dome-like)
   - Gravity still pulls creatures down

NEW FITNESS FUNCTION (how we measure success):
   - Measure the MAXIMUM HEIGHT the creature reached
   - Height = z-coordinate (how high off the ground)
   - The creature should climb the mountain, not fly through the air
   - Higher on mountain = better fitness = more likely to reproduce

CHALLENGE:
   - Climbing requires different skills than moving horizontally
   - Creatures need to grip, push, pull themselves upward
   - They need to stay on the mountain surface (not cheat by flying)
   - This is much harder than the original task!

WHAT SHOULD EVOLVE:
   - Creatures with gripping appendages
   - Bodies that can push themselves upward
   - Movement patterns that work against gravity
   - Designs we might never think of manually!

================================================================================
6. HOW DOES THE WHOLE SYSTEM WORK STEP-BY-STEP?
================================================================================

Let me walk through ONE complete generation of evolution:

PHASE 1: INITIALIZATION (Generation 0)
--------------------------------------
1. Create population of 10 random creatures
   - Each has random DNA (random numbers)
   - DNA determines: body parts, connections, motor behaviors
   - Most creatures will look weird and won't work well

2. For each creature, decode its DNA into an actual robot:
   - Read DNA to determine: "3 body segments"
   - Read DNA to determine: "segment 1: length=0.8, radius=0.2"
   - Read DNA to determine: "segment 2 connects to segment 1"
   - Read DNA to determine: "motor 1: PULSE type, freq=0.5"
   - Build a 3D robot model (URDF file format)

PHASE 2: SIMULATION
-------------------
3. For EACH creature (10 creatures total):
   
   a) Load the 3D mountain environment
      - Create arena walls
      - Load mountain shape from file
      - Set gravity to -10 (pulls down)
   
   b) Place creature at starting position (0, 0, 10)
      - Creature drops onto the mountain
   
   c) Run physics simulation for 2400 time steps (about 10 seconds):
      - Every 24 steps (0.1 seconds):
        * Update motors (calculate new joint velocities)
        * Apply motor forces to joints
      - Every step:
        * Physics engine calculates:
          - Gravity pulling creature down
          - Collisions with mountain surface
          - Joint movements from motors
        * Record creature's position
        * Update maximum height if creature climbed higher
   
   d) After simulation ends:
      - Record final fitness = maximum height achieved
      - Example: Creature reached z=3.5 meters → fitness = 3.5

4. After testing all 10 creatures, we have fitness scores:
   - Creature 0: fitness = 1.2
   - Creature 1: fitness = 0.5
   - Creature 2: fitness = 2.8
   - Creature 3: fitness = 0.3
   - Creature 4: fitness = 1.9
   - Creature 5: fitness = 0.1
   - Creature 6: fitness = 3.1  ← Best one!
   - Creature 7: fitness = 1.5
   - Creature 8: fitness = 0.7
   - Creature 9: fitness = 2.2

PHASE 3: SELECTION & REPRODUCTION
----------------------------------
5. Create a "fitness map" for selection:
   - This gives each creature a probability of being selected
   - Better fitness → higher probability
   - Creature 6 (fitness=3.1) has highest chance
   - Creature 5 (fitness=0.1) has lowest chance

6. Create next generation (10 new creatures):
   
   For each of the 10 slots in next generation:
   
   a) SELECT TWO PARENTS:
      - Randomly select parent 1 (weighted by fitness)
        Example: Creature 6 selected (it's fit!)
      - Randomly select parent 2 (weighted by fitness)
        Example: Creature 2 selected (also pretty fit!)
   
   b) CROSSOVER (combine DNA):
      - Parent 1 DNA: [0.2, 0.5, 0.8, 0.1, 0.9, 0.3]
      - Parent 2 DNA: [0.7, 0.3, 0.4, 0.6, 0.2, 0.5]
      - Randomly choose a split point, say position 3
      - Child DNA: [0.2, 0.5, 0.8] from parent 1
                 + [0.6, 0.2, 0.5] from parent 2
                 = [0.2, 0.5, 0.8, 0.6, 0.2, 0.5]
      - This is like sexual reproduction in biology!
   
   c) MUTATION (random changes):
      - POINT MUTATION: Randomly change some DNA values
        Before: [0.2, 0.5, 0.8, 0.6, 0.2, 0.5]
        After:  [0.3, 0.5, 0.8, 0.6, 0.1, 0.5]
        (changed positions 0 and 4 slightly)
      
      - GROW MUTATION: Maybe add a new gene (body part)
        Before: [0.2, 0.5, 0.8, 0.6, 0.2, 0.5]  (6 genes)
        After:  [0.2, 0.5, 0.8, 0.6, 0.2, 0.5, 0.4]  (7 genes)
        (creature now has one more body part!)
      
      - SHRINK MUTATION: Maybe remove a gene
        Before: [0.2, 0.5, 0.8, 0.6, 0.2, 0.5]  (6 genes)
        After:  [0.2, 0.5, 0.6, 0.2, 0.5]  (5 genes)
        (creature lost a body part)
   
   d) CREATE NEW CREATURE:
      - Child creature now has this new DNA
      - It's similar to its parents but not identical
      - Mutations might make it better or worse!

7. ELITISM (keep the best):
   - Automatically copy the BEST creature to next generation
   - Creature 6 (fitness=3.1) automatically survives
   - This ensures we never lose our best solution
   - It goes in slot 0 of the new generation

8. Now we have Generation 1 with 10 new creatures:
   - Creature 0: exact copy of best from Generation 0
   - Creatures 1-9: children of fit parents with mutations

PHASE 4: REPEAT
---------------
9. Go back to PHASE 2 and test Generation 1
   - See if any creatures in Generation 1 climb higher
   - Maybe one reaches height 3.5 (better than 3.1!)
   - Evolution is working!

10. Create Generation 2, Generation 3, etc.
    - After 100 generations, creatures might reach height 8.0
    - After 500 generations, creatures might reach height 12.0
    - They get better and better!

================================================================================
7. WHAT DO I NEED TO DO FOR PART B?
================================================================================

My job is to ADAPT the existing code to work with mountain climbing:

BASIC REQUIREMENTS (Must Complete):
------------------------------------

TASK 1: Modify creature.py
   - Add ability to track maximum height
   - Add new methods:
     * update_max_height(position) - updates if creature climbed higher
     * get_max_height() - returns the max height achieved
   WHY: We need to measure how high the creature climbed

TASK 2: Create simulation_mountain.py
   - Copy the existing simulation.py file
   - Replace the flat plane with mountain environment
   - Load the arena (sandbox with walls)
   - Load the mountain shape (Gaussian pyramid)
   - Track max height during simulation instead of distance
   WHY: We need the mountain environment to test climbing

TASK 3: Create test_ga_mountain.py
   - Copy the existing test_ga.py file
   - Use mountain simulation instead of flat simulation
   - Use get_max_height() as fitness instead of get_distance_travelled()
   - Keep the same GA loop (selection, crossover, mutation)
   WHY: This is the main script that runs the evolution

TASK 4: Run experiments and collect data
   - Test with different population sizes (5, 10, 20, 50 creatures)
   - Test with different gene counts (2, 3, 5, 10 genes)
   - Test with different mutation rates (0.05, 0.1, 0.25)
   - Create graphs showing:
     * How fitness improves over generations
     * How different settings affect evolution speed
     * How body complexity changes over time
   WHY: Need to analyze what works best

TASK 5: Write a report (1,500-2,000 words)
   - Explain what experiments I did
   - Show graphs and tables of results
   - Analyze what worked and what didn't
   WHY: Document my findings

ADVANCED REQUIREMENTS (For Higher Marks):
------------------------------------------

TASK 6: Experiment with the encoding scheme
   - Change how DNA encodes the creature
   - Try different motor control schemes:
     * Different frequency ranges
     * Different amplitude ranges
     * New motor types
   - Try different body part shapes:
     * Make links thicker/thinner
     * Make links longer/shorter
   - Try selective evolution:
     * Fix the base body, only evolve the legs
     * Or fix the legs, only evolve the body
   WHY: Explore how encoding affects evolution

EXCEPTIONAL REQUIREMENTS (For 80%+ grade):
-------------------------------------------

TASK 7: Different mountain shapes
   - Use prepare_shapes.py to generate different mountains:
     * Steeper mountains
     * Mountains with noise (bumpy surface)
     * Taller/shorter mountains
   - Test if creatures evolved for one mountain work on others
   WHY: See if creatures can generalize

TASK 8: Sensory input (optional, advanced)
   - Give creatures awareness of their environment
   - Motors can respond to:
     * Distance to mountain peak
     * Direction to mountain peak
     * Current angle/orientation
   - This makes them "smarter"
   WHY: Explore reactive vs. programmed behavior

DELIVERABLES (What I Must Submit):
-----------------------------------
1. Report (PDF, 1,500-2,000 words) with graphs and tables
2. All code in single PDF with highlighted sections showing my work
3. Video (5 minutes) showing evolved creatures climbing
4. Optional: "Why my work is exceptional" statement

================================================================================
8. SIMPLE ANALOGY TO UNDERSTAND EVERYTHING
================================================================================

Imagine you want to breed dogs that are good at climbing mountains:

GENERATION 0:
   - You start with 10 random dogs (poodles, bulldogs, random mutts)
   - You take them to a mountain
   - Most dogs can barely climb (they're not bred for this!)
   - One dog (a mutt with long legs) gets higher than others

SELECTION:
   - You let the dogs that climbed highest have puppies
   - The worst climbers don't get to reproduce
   - Natural selection at work!

GENERATION 1:
   - You now have 10 puppies
   - They inherit traits from parent dogs (long legs, strong muscles)
   - But there are random mutations (some have longer tails, bigger paws)
   - You test them on the mountain
   - Some climb even higher than their parents!

GENERATION 2, 3, 4, ..., 100:
   - Keep breeding the best climbers
   - After many generations, you have SUPER CLIMBING DOGS
   - They have traits you never specifically bred for:
     * Extra grippy paws
     * Lower center of gravity
     * Specialized muscle distribution
   - Evolution figured out what works!

THE COURSEWORK IS THE SAME, BUT:
   - Instead of dogs → robot creatures
   - Instead of real world → physics simulation
   - Instead of years → seconds (simulation is fast!)
   - Instead of manual breeding → computer does it automatically

================================================================================
FINAL SUMMARY IN ONE PARAGRAPH:
================================================================================

This coursework uses a GENETIC ALGORITHM (simulated evolution) to automatically
design robots that can climb a virtual mountain. We start with random robots
that have DNA (numbers encoding their body shape and movement). We test each
robot in a physics simulation to see how high it climbs. The best climbers get
to "reproduce" by combining their DNA, with random mutations added. After many
generations, the robots evolve to be better climbers without us explicitly
programming how to climb. My job is to modify the existing code (which evolved
robots to move horizontally) to instead evolve robots that climb a mountain,
run experiments with different settings, and analyze the results.

================================================================================
END OF SUMMARY
================================================================================