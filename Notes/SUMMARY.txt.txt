================================================================================
                    CM3020 AI COURSEWORK - PART B SUMMARY
                    A Beginner-Friendly Explanation
================================================================================

TABLE OF CONTENTS:
1. What is this coursework about?
2. What is a Genetic Algorithm?
3. What are these "creatures"?
4. What was the ORIGINAL task?
5. What is the NEW task (Part B)?
6. How does the whole system work step-by-step?
7. What do I need to do for Part B?
8. Simple analogy to understand everything
9. Bug Fixes and Improvements (v2.0)

================================================================================
1. WHAT IS THIS COURSEWORK ABOUT?
================================================================================

Imagine you want to create robots that can move around and accomplish tasks,
but you don't want to manually design them. Instead, you want the computer to
"evolve" better and better robots automatically, similar to how animals evolved
in nature over millions of years.

This coursework is about using EVOLUTION and NATURAL SELECTION (concepts from
biology) to automatically design robots that can climb a mountain in a
simulated 3D physics world.

================================================================================
2. WHAT IS A GENETIC ALGORITHM?
================================================================================

A Genetic Algorithm (GA) is a computer program inspired by biological evolution.
Here's how it works in simple terms:

STEP 1 - CREATE RANDOM POPULATION:
   - Start with a bunch of random "creatures" (robots)
   - Each creature is different (different body shapes, different movements)
   - Most of them will be terrible at the task!

STEP 2 - TEST EACH CREATURE:
   - Put each creature in a physics simulation
   - See how well it performs (this is called "fitness")
   - Example: "Did it move forward? Did it climb high?"

STEP 3 - SELECT THE BEST ONES:
   - The creatures that performed best get to "reproduce"
   - The worst creatures "die off" and don't get to have children
   - This is natural selection!

STEP 4 - CREATE NEXT GENERATION:
   - Take the best creatures and combine their "DNA" to make children
   - Add some random mutations (small random changes)
   - This creates a new generation of creatures

STEP 5 - REPEAT:
   - Test the new generation
   - Select the best ones again
   - Create another generation
   - Keep doing this for hundreds of generations

RESULT:
   After many generations, the creatures get better and better at the task!
   They "evolve" to be good climbers without anyone explicitly programming
   how to climb.

================================================================================
3. WHAT ARE THESE "CREATURES"?
================================================================================

The creatures are simulated robots made of:

BODY PARTS (called "links"):
   - Cylindrical segments (like robot limbs or body segments)
   - Each segment has properties: length, radius, mass
   - Segments can be connected to each other
   - MINIMUM SIZE ENFORCED: length >= 0.1, radius >= 0.05 (prevents instability)

JOINTS (connections between body parts):
   - Connect one body part to another
   - All joints are revolute type (can rotate like your elbow)
   - Have motors that make them move
   - POSITIONED AT LINK ENDPOINTS: Joints connect at the end of parent links
     (prevents floating/detached limbs)

MOTORS (what makes the creature move):
   - Control the joints with force = 5N (constant for fair testing)
   - Can move in different patterns:
     * PULSE: on-off-on-off (like a piston)
     * SINE: smooth wave motion (like swimming)
   - Each motor has: frequency (how fast)
   - Amplitude is constant at 1.0 for all creatures (fair testing)

DNA (genetic code):
   - Each creature has "DNA" - a list of numbers (0 to 1)
   - These numbers encode EVERYTHING about the creature:
     * How many body parts it has
     * What size/shape each part is (with minimum sizes enforced)
     * How the parts connect together
     * How the motors move
   - When two creatures "reproduce", their DNA combines
   - Mutations randomly change some numbers in the DNA
   - DEEP COPY: Mutations don't corrupt parent DNA anymore

LINK RECURRENCE:
   - Each gene can create 1-3 copies of a link (reduced from 1-4)
   - This creates simpler, more evolvable creatures

PHYSICS:
   - Proper inertia calculated for each link based on its dimensions
   - Formula: Ixx = Iyy = (1/12) * m * (3r² + h²), Izz = (1/2) * m * r²
   - This ensures realistic rotation and movement

================================================================================
4. WHAT WAS THE ORIGINAL TASK?
================================================================================

In the original Genetic Algorithm case study, creatures were trying to:

TASK: Move as far as possible across a FLAT GROUND

ENVIRONMENT:
   - Flat plane (like a floor)
   - Gravity pulling creatures down
   - Physics simulation (creatures can fall, slide, roll)

FITNESS FUNCTION (how we measure success):
   - Measure the DISTANCE the creature traveled
   - Start position: (0, 0, 0)
   - End position: wherever it ended up after simulation
   - Fitness = distance between start and end
   - Higher distance = better fitness = more likely to reproduce

WHAT EVOLVED:
   - Creatures that could crawl, walk, roll, or wiggle across the ground
   - Different body shapes emerged: snake-like, spider-like, worm-like
   - The GA discovered movement strategies automatically!

================================================================================
5. WHAT IS THE NEW TASK (PART B)?
================================================================================

Part B changes the environment and the goal:

NEW TASK: Climb as HIGH as possible up a MOUNTAIN

NEW ENVIRONMENT:
   - A sandbox arena (40x40 units with walls)
   - A mountain in the middle of the arena (Gaussian pyramid shape)
   - Mountain peak is at coordinates (0, 0) with maximum height ~5 units
   - Gravity pulls creatures down at 10 m/s²

NEW FITNESS FUNCTION (how we measure success):
   - HYBRID FITNESS = height_climbed + proximity_to_center
   - Height: Maximum z-coordinate reached relative to baseline
   - Proximity: How close to mountain peak (0, 0) - ranges from 0 to 5.0
   - Baseline is set after creature settles (prevents spawn height cheating)

SPAWN POSITION:
   - Creatures spawn at (-3, 0, 2) - close to mountain base on gentler slope
   - 480 steps settling time before fitness tracking begins

CHALLENGE:
   - Climbing requires different skills than moving horizontally
   - Creatures need to grip, push, pull themselves upward
   - They need to stay on the mountain surface (not cheat by flying)
   - Motor force of 5N provides consistent testing conditions

================================================================================
6. HOW DOES THE WHOLE SYSTEM WORK STEP-BY-STEP?
================================================================================

Let me walk through ONE complete generation of evolution:

PHASE 1: INITIALIZATION (Generation 0)
--------------------------------------
1. Create population of 10 random creatures
   - Each has random DNA (random numbers 0-1)
   - DNA determines: body parts, connections, motor behaviors
   - Most creatures will look weird and won't work well

2. For each creature, decode its DNA into an actual robot:
   - Read DNA to determine body segments (1-3 copies per gene)
   - Enforce minimum sizes (length >= 0.1, radius >= 0.05)
   - Calculate proper inertia for each link
   - Position joints at link endpoints (no floating limbs)
   - Build a 3D robot model (URDF file format)

PHASE 2: SIMULATION
-------------------
3. For EACH creature (10 creatures total):

   a) Load the 3D mountain environment
      - Create 40x40 arena with walls
      - Load Gaussian pyramid mountain
      - Set gravity to -10 m/s²

   b) Place creature at starting position (-3, 0, 2)
      - Creature settles for 480 steps (2 seconds)
      - Baseline height recorded after settling

   c) Run physics simulation for 2400 time steps (~10 seconds):
      - Every 24 steps (0.1 seconds):
        * Update motors (calculate new joint velocities)
        * Apply motor forces (5N) to joints
      - Every step:
        * Physics engine calculates gravity, collisions, movements
        * Record creature's position
        * Update maximum height if creature climbed higher

   d) After simulation ends:
      - Calculate hybrid fitness = max_height + proximity_score
      - Example: Creature reached height 2.5, distance 2.0 from center
        Fitness = 2.5 + (3.0 - 2.0) = 3.5

PHASE 3: SELECTION & REPRODUCTION
----------------------------------
5. Create a "fitness map" for selection:
   - Better fitness → higher probability of being selected
   - Fitness-proportionate selection

6. Create next generation (10 new creatures):

   For each of the 10 slots in next generation:

   a) SELECT TWO PARENTS (weighted by fitness)

   b) CROSSOVER (combine DNA):
      - Take genes from both parents
      - Create child DNA

   c) MUTATION (random changes):
      - POINT MUTATION: Change DNA values by ±amount (configurable!)
      - GROW MUTATION: Maybe add a new gene (new body part)
      - SHRINK MUTATION: Maybe remove a gene
      - All mutations use DEEP COPY (don't corrupt parent DNA)

   d) CREATE NEW CREATURE with mutated DNA

7. ELITISM: Best creature automatically survives to next generation

PHASE 4: REPEAT
---------------
8. Go back to PHASE 2 and test new generation
9. Evolution continues for hundreds of generations

================================================================================
7. WHAT DO I NEED TO DO FOR PART B?
================================================================================

COMPLETED REQUIREMENTS:
-----------------------

TASK 1: Modified creature.py
   - Added max_height tracking with baseline comparison
   - Added get_max_height() method for fitness
   - Added get_hybrid_fitness() combining height + proximity
   - Fixed spawn distance calculation (5.0, not 7.8)

TASK 2: Modified simulation.py
   - Replaced flat plane with mountain environment
   - Added make_arena() and load_mountain() functions
   - Spawn creatures at (-3, 0, 2) near mountain base on gentler slope
   - Track height relative to baseline (after settling)
   - Motor force at 5N for consistent testing

TASK 3: Created test_ga_mountain.py
   - Uses mountain simulation
   - Uses get_hybrid_fitness() for selection
   - Saves elite creatures to CSV files

TASK 4: Created experiment files
   - experiment_gene_count.py: Tests 2, 3, 5, 10 genes
   - experiment_population_size.py: Tests 5, 10, 20, 50 population
   - experiment_mutation_rates.py: Tests low/medium/high rates

BUG FIXES APPLIED (v2.0):
------------------------
   - Fixed joint limits (upper/lower were swapped)
   - Fixed floating limbs (joint positions now relative to link length)
   - Fixed mutation amount parameter (was ignored)
   - Fixed shallow copy corruption in mutations
   - Added minimum link sizes
   - Added proper inertia calculation
   - Reduced recurrence scale for simpler creatures
   - Increased motor force for better climbing
   - Fixed spawn distance in fitness calculation

================================================================================
8. SIMPLE ANALOGY TO UNDERSTAND EVERYTHING
================================================================================

Imagine you want to breed dogs that are good at climbing mountains:

GENERATION 0:
   - You start with 10 random dogs (all physically sound - no floating legs!)
   - You take them to a mountain
   - Most dogs can barely climb (they're not bred for this!)
   - One dog (with strong legs) gets higher than others

SELECTION:
   - You let the dogs that climbed highest have puppies
   - The worst climbers don't get to reproduce
   - Natural selection at work!

GENERATION 1:
   - You now have 10 puppies
   - They inherit traits from parent dogs
   - Random mutations occur (puppies aren't exact copies)
   - Mutations don't affect the parents (deep copy!)
   - You test them on the mountain
   - Some climb even higher than their parents!

GENERATION 2, 3, 4, ..., 100:
   - Keep breeding the best climbers
   - After many generations, you have SUPER CLIMBING DOGS
   - Evolution figured out what works!

THE COURSEWORK IS THE SAME, BUT:
   - Instead of dogs → robot creatures (with proper physics)
   - Instead of real world → physics simulation (PyBullet)
   - Instead of years → seconds (simulation is fast!)
   - Instead of manual breeding → computer does it automatically

================================================================================
9. BUG FIXES AND IMPROVEMENTS (v2.0)
================================================================================

CRITICAL FIXES:
1. Joint limits corrected (upper/lower were backwards)
2. Floating limbs eliminated (joints now at link endpoints)
3. Mutation amount parameter now works
4. Motor amplitude standardized (constant 1.0)
5. Dead code removed (joint type branches)

HIGH-PRIORITY FIXES:
6. Minimum link sizes enforced (prevents physics crashes)
7. Proper inertia calculation (realistic rotation)
8. Recurrence scale reduced (simpler creatures)
9. Shallow copy bug fixed (mutations don't corrupt parents)
10. Motor force at 5N (constant for fair testing)
11. Spawn distance corrected (fitness calculation accurate)
12. Spawn moved closer to mountain (-3, 0, 2)
13. Creature size reduced by 1/3 (link-length: 1.3, link-radius: 0.65)
14. Joint origin axis corrected (Z-axis, not X-axis) - fixes floating limbs
15. Parent link length stored in child for proper joint positioning

See CHANGES.txt.txt for detailed before/after code snippets.

================================================================================
HOW TO RUN THE SYSTEM
================================================================================

cw-envt.py = Visual demo (1 creature, GUI, just to see the environment)
test_ga_mountain.py = Actual genetic algorithm (10 creatures, evolves 1000 gen)
realtime_from_csv.py elite_creatures/elite_mountain_X.csv = Visualize creature
run_all_experiments.py = Run full experiments and generate graphs

================================================================================
FITNESS CALCULATION
================================================================================

fitness = max_height + proximity_score

Where:
- max_height = highest z-coordinate reached (relative to settled baseline)
- proximity_score = 3.0 - distance_to_center (rewards getting closer to peak)

This rewards BOTH climbing AND getting closer to the peak.

================================================================================
END OF SUMMARY
================================================================================
