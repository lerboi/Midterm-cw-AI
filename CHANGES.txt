================================================================================
CM3020 AI COURSEWORK PART B - CODE MODIFICATIONS LOG
================================================================================

This document logs all modifications made to address the PDF Part B requirement:
"get as high as possible up the mountain, without cheating and flying into the air"

================================================================================
1. FITNESS FUNCTION - SIMPLIFIED FOR CLIMBING (creature.py)
================================================================================

PROBLEM: Creatures were evolving to be TALL or just standing still rather than
         actually CLIMBING. The original grounding bonus (0.5 for staying
         grounded) was rewarding stationary creatures over mobile ones.

CURRENT FITNESS FUNCTION (get_climbing_fitness):
    fitness = (progress * 2.5) + final_height + movement_bonus - surface_penalty

COMPONENTS:
1. Progress toward peak (weight: 2.5x) - PRIMARY REWARD
   - Measures: initial_distance_to_peak - final_distance_to_peak
   - Rewards horizontal movement toward mountain center (0, 0)
   - Heavily weighted because PDF says "maximum closeness to the top"

2. Final height (weight: 1.0x)
   - Measures: final_position[2] - baseline_height
   - Rewards vertical climbing (lowest point of creature)

3. Movement bonus (capped at 1.5)
   - Measures: distance_travelled * 0.3 (max 1.5)
   - Rewards ANY movement to encourage locomotion development
   - Even moving away from peak is better than standing still

4. Surface penalty
   - Measures: max(0, height_above_surface - 0.5) * 0.5
   - Penalizes creatures floating/flying above the mountain surface

REMOVED: Grounding bonus (was rewarding stationary creatures)

WHY: The PDF requires "maximum closeness to the top of the mountain". The
     previous fitness gave 0.5 just for standing still (grounding bonus),
     which dominated early evolution and selected for stable non-moving
     creatures. By removing grounding bonus and adding movement bonus,
     creatures that develop any locomotion capability are now rewarded.

================================================================================
2. LOWEST POINT TRACKING - ALL LINKS (simulation.py, realtime_from_csv.py)
================================================================================

PROBLEM: PyBullet's getAABB(bodyId) with default linkIndex=-1 only returns the
         AABB of the BASE LINK, not the entire creature. A creature with a tall
         limb extending from a small base would still measure only the base's
         low position, not accounting for the limb.

CHANGES:
- Updated get_lowest_point() to iterate through ALL links of the creature
- For each link (base + all child links), get its AABB and track the minimum Z
- Returns the true lowest Z coordinate across the entire creature body

CODE:
    def get_lowest_point(self, creature_id, pid):
        # Start with base link AABB
        aabb_min, aabb_max = p.getAABB(creature_id, -1, physicsClientId=pid)
        lowest_z = aabb_min[2]
        # Check all child links
        num_joints = p.getNumJoints(creature_id, physicsClientId=pid)
        for link_idx in range(num_joints):
            link_aabb_min, _ = p.getAABB(creature_id, link_idx, physicsClientId=pid)
            if link_aabb_min[2] < lowest_z:
                lowest_z = link_aabb_min[2]
        return lowest_z

WHY: This prevents tall creatures from gaming the fitness. The true lowest
     point of the entire creature (including all limbs) is used for height
     measurement. A creature cannot gain fitness by simply having tall limbs.

================================================================================
3. GROUND CONTACT DETECTION (simulation.py, realtime_from_csv.py)
================================================================================

CHANGES:
- Added check_ground_contact() using PyBullet's getContactPoints() API
- Tracks contact with both mountain and floor surfaces
- Grounding bonus in fitness rewards creatures that maintain ground contact

WHY: A creature that "climbs" should be in contact with the climbing surface.
     This prevents rewarding creatures that jump, fly, or fall through the air.

================================================================================
4. SPAWN POSITION CONSISTENCY (simulation.py, realtime_from_csv.py)
================================================================================

CHANGES:
- Standardized spawn position to [5, 0, 3] in both training and testing
- Updated initial_distance_to_peak to 5.0 to match

WHY: Training and testing must use identical conditions for fair evaluation.

================================================================================
5. GA PARAMETERS - INCREASED EXPLORATION (test_ga.py, test_ga_mountain.py)
================================================================================

PROBLEM: Creatures were converging to simple cylinder shapes (local optimum).
         The shrink rate was higher than grow rate, causing loss of complexity.

CHANGES:
| Parameter          | Old Value | New Value | Reason                          |
|--------------------|-----------|-----------|----------------------------------|
| pop_size           | 10        | 15        | More diversity per generation    |
| gene_count         | 3         | 4         | Start with more body segments    |
| point_mutate rate  | 0.1       | 0.25      | More frequent gene changes       |
| point_mutate amount| 0.25      | 0.5       | Larger mutations to escape optima|
| shrink_mutate rate | 0.25      | 0.1       | Less likely to lose limbs        |
| grow_mutate rate   | 0.1       | 0.25      | More likely to add new limbs     |

WHY: The original shrink > grow ratio (0.25 > 0.1) caused creatures to lose
     limbs faster than they gained them, converging to simple shapes. The new
     grow > shrink ratio (0.25 > 0.1) encourages more complex creatures that
     can develop locomotion strategies for climbing.

================================================================================
6. MOTOR FORCE INCREASE (simulation.py, realtime_from_csv.py)
================================================================================

PROBLEM: Creatures may not have enough motor force to generate locomotion,
         especially on an inclined surface like the mountain.

CHANGES:
- Increased motor force from 5 to 12 in setJointMotorControl2()

CODE:
    p.setJointMotorControl2(cid, jid,
            controlMode=p.VELOCITY_CONTROL,
            targetVelocity=m.get_output(),
            force=12,  # Was 5
            physicsClientId=self.physicsClientId)

WHY: Higher motor force allows creatures to actually move their limbs with
     enough power to generate locomotion. The original force=5 may have been
     insufficient for creatures to overcome friction and gravity on the slope.

================================================================================
7. LOG LABEL CORRECTION (test_ga_mountain.py)
================================================================================

CHANGES:
- Changed log output from "max height:" to "max fitness:"

WHY: The logged value is get_climbing_fitness(), not raw height. Accurate
     labeling prevents confusion during training observation.

================================================================================
FILES MODIFIED SUMMARY
================================================================================

creature.py:
  - get_climbing_fitness(): Simplified fitness function
    * Removed grounding bonus (was causing stationary creatures)
    * Progress weight increased to 2.5x
    * Added movement bonus (capped at 1.5)
    * Kept surface penalty for anti-flying
  - Tracking variables for fitness calculation

simulation.py:
  - get_lowest_point(): Now iterates ALL links (not just base)
  - check_ground_contact(): Using getContactPoints() API
  - Motor force: 5 -> 12
  - Spawn position: [5, 0, 3]

realtime_from_csv.py:
  - get_lowest_point(): Now iterates ALL links (matches simulation.py)
  - Motor force: Added force=12
  - Spawn position: [5, 0, 3] (matches training)

test_ga.py & test_ga_mountain.py:
  - pop_size: 10 -> 15
  - gene_count: 3 -> 4
  - point_mutate: rate=0.1->0.25, amount=0.25->0.5
  - shrink_mutate: rate=0.25 -> 0.1
  - grow_mutate: rate=0.1 -> 0.25
  - Log label: "max fitness:" instead of "max height:"

================================================================================
EXPECTED BEHAVIOR AFTER CHANGES
================================================================================

Before: Creatures evolved to be tall cylinders that stood still (grounding
        bonus = 0.5 dominated fitness).

After:  Creatures should evolve locomotion because:
        1. Standing still gives ~0 fitness (no progress, no movement bonus)
        2. Any movement gives positive movement bonus (up to 1.5)
        3. Moving toward peak gives 2.5x progress reward
        4. Higher motor force enables actual locomotion
        5. True lowest point tracking prevents tall-limb exploitation

================================================================================
8. JOINT LIMITS - INCREASED FOR LOCOMOTION (genome.py)
================================================================================

PROBLEM: After 1000+ generations, creatures still could not climb. The URDF
         joint limits were acting as a physical bottleneck:
         - Joint effort limit = 1 Nm (motor applies 12, but joint caps at 1)
         - Joint velocity limit = 1 rad/s (too slow for locomotion)

         The motor force (12) was being wasted because the joint itself could
         only transmit 1 Nm of torque. This is like having a powerful engine
         connected to a weak transmission.

CHANGES:
| Parameter       | Old Value | New Value | Reason                              |
|-----------------|-----------|-----------|-------------------------------------|
| Joint effort    | 1 Nm      | 10 Nm     | Allow motor force to transfer       |
| Joint velocity  | 1 rad/s   | 5 rad/s   | Enable faster joint movement        |

CODE (genome.py, to_joint_element method):
    limit_tag.setAttribute("effort", "10")    # Was "1"
    limit_tag.setAttribute("velocity", "5")   # Was "1"

WHY: The PDF allows modifications to "motor controls" and "shape of the parts
     of the robot". Joint limits define how the robot's parts can move, which
     falls under allowable modifications. Without this change, creatures
     physically CANNOT generate sufficient torque or speed for climbing.

================================================================================
9. MOTOR FREQUENCY SCALE - INCREASED FOR FASTER OSCILLATION (genome.py)
================================================================================

PROBLEM: The control-freq gene had a scale of 1, meaning motor oscillation
         frequency ranged from 0-1 Hz. This is too slow for effective
         locomotion - creatures need faster oscillating movements to crawl
         or walk up the mountain.

CHANGES:
| Parameter        | Old Value | New Value | Reason                            |
|------------------|-----------|-----------|-----------------------------------|
| control-freq     | scale: 1  | scale: 3  | Allow 0-3 Hz motor oscillation    |

CODE (genome.py, get_gene_spec method):
    "control-freq":{"scale":3}  # Was {"scale":1}

WHY: Higher frequency oscillation enables faster leg/limb movements. Combined
     with the increased joint velocity limit (5 rad/s), creatures can now
     evolve gaits with faster stepping patterns needed for climbing.

================================================================================
10. GENE COUNT - INCREASED FOR MORE COMPLEX BODY STRUCTURES
================================================================================

PROBLEM: With gene_count=4, creatures could only have 4 body segments maximum.
         This limits the complexity of body plans - creatures need more parts
         to evolve effective locomotion strategies like multiple legs or
         articulated limbs.

CHANGES:
| File                 | Old Value | New Value | Reason                         |
|----------------------|-----------|-----------|--------------------------------|
| test_ga_mountain.py  | 4         | 6         | More body segments for climbing|
| test_ga.py           | 4         | 6         | Consistent with main GA        |
| test_ga_no_threads.py| 3         | 6         | Consistent with main GA        |

CODE (test_ga_mountain.py, test_ga.py, test_ga_no_threads.py):
    pop = population.Population(pop_size=15, gene_count=6)  # Was 4 or 3

WHY: More genes allow creatures to evolve more complex body plans with
     additional limbs or segments. This increases the search space but also
     enables more sophisticated locomotion strategies. 6 parts can form
     body + 5 limbs (like a starfish) or body + 2 arms + 2 legs + tail.

================================================================================
11. LINK SHAPES - IMPLEMENTED SHAPE VARIATION (cylinder, sphere, box)
================================================================================

PROBLEM: The `link-shape` gene was defined in the gene spec but NEVER USED.
         All body parts were always cylinders regardless of the gene value.
         This prevented creatures from evolving different body part shapes
         that might be better suited for climbing (e.g., spheres for rolling,
         boxes for grip).

CHANGES:
| Component          | Old Behavior           | New Behavior                    |
|--------------------|------------------------|---------------------------------|
| link-shape gene    | Defined but ignored    | Now determines shape type       |
| Shape selection    | Always cylinder        | 0-0.33: cylinder, 0.33-0.66: sphere, 0.66-1.0: box |
| URDFLink.__init__  | No link_shape param    | Added link_shape parameter      |
| genome_to_links    | No link-shape passed   | Now passes link-shape to URDFLink |
| to_link_element    | Only creates cylinders | Creates cylinder/sphere/box     |
| Inertia calc       | Cylinder formula only  | Proper formulas for each shape  |

CODE (genome.py):

1. URDFLink.__init__ now accepts link_shape parameter:
    def __init__(self, name, parent_name, recur,
                link_shape=0.1,  # NEW
                link_length=0.1,
                ...

2. genome_to_links passes link-shape gene:
    link = URDFLink(name=link_name,
                    parent_name=parent_name,
                    recur=recur,
                    link_shape=gdict["link-shape"],  # NEW
                    ...

3. to_link_element creates different shapes:
    if self.link_shape <= 0.33:
        # Cylinder
        shape_tag = adom.createElement("cylinder")
    elif self.link_shape <= 0.66:
        # Sphere
        shape_tag = adom.createElement("sphere")
    else:
        # Box
        shape_tag = adom.createElement("box")

4. Inertia calculated correctly for each shape type:
    - Cylinder: Ixx = (1/12) * m * (3*r^2 + h^2)
    - Sphere:   Ixx = Iyy = Izz = (2/5) * m * r^2
    - Box:      Proper cuboid inertia formulas

WHY: Different shapes provide different locomotion advantages:
     - Cylinders: Good for rolling, standard limb shape
     - Spheres: Can roll in any direction, good for feet/joints
     - Boxes: More surface area for grip, stable base

     The PDF allows modifications to "shape of the parts of the robot".
     This enables the GA to explore a much richer morphology space.

================================================================================
12. SPAWN HEIGHT FIX - CREATURES NOW SPAWN ON MOUNTAIN SURFACE (simulation.py)
================================================================================

PROBLEM: Creatures were spawning at z=3, but the mountain surface at x=5 is
         only at z≈0.25 (calculated from Gaussian formula). This meant
         creatures were FALLING 2.75 UNITS at the start of every simulation,
         causing them to crash/flip before they could even attempt to move.

         This explains why creatures weren't climbing - they were damaged
         at spawn.

CHANGES:
| Parameter      | Old Value     | New Value                           |
|----------------|---------------|-------------------------------------|
| spawn_x        | 5.0           | 3.0 (closer to peak)                |
| spawn_z        | 3.0 (fixed)   | surface_z + 0.5 (calculated)        |
| initial_dist   | 5.0 (fixed)   | sqrt(x² + y²) (calculated)          |

CODE (simulation.py, run_creature method):
    spawn_x = 3.0
    spawn_y = 0.0
    surface_z = 5.0 * math.exp(-(spawn_x**2 + spawn_y**2) / 18.0) - 1.0
    spawn_z = surface_z + 0.5  # 0.5 units above surface
    cr.initial_distance_to_peak = math.sqrt(spawn_x**2 + spawn_y**2)

WHY: Creatures must start on the mountain surface to have any chance of
     climbing. The Gaussian formula matches the mountain shape in
     gaussian_pyramid.urdf. Spawning closer (x=3) gives creatures a better
     starting position on the slope.

================================================================================
13. MOTOR AMPLITUDE - NOW USES CONTROL_AMP GENE (creature.py)
================================================================================

PROBLEM: Motor amplitude was hardcoded to 1.0, ignoring the control_amp gene.
         This meant all motors had identical strength, preventing evolution
         from tuning motor power for different limbs.

CHANGES:
| Parameter      | Old Value              | New Value                      |
|----------------|------------------------|--------------------------------|
| self.amp       | 1.0 (hardcoded)        | 0.5 + (control_amp * 4.0)      |
| Range          | Always 1.0             | 0.5 to 1.5                     |

CODE (creature.py, Motor.__init__):
    self.amp = 0.5 + (control_amp * 4.0)  # control_amp is 0-0.25 after scaling

WHY: Different limbs may need different motor strengths. Legs pushing against
     ground may need more power than arms. This allows evolution to optimize
     motor strength per joint.

================================================================================
14. MOVEMENT BONUS - INCREASED TO REWARD LOCOMOTION (creature.py)
================================================================================

PROBLEM: Movement bonus was capped at 1.5 with 0.3x multiplier, while progress
         toward peak was weighted 2.5x. This meant:
         - Moving 0.6 units toward peak = 1.5 fitness
         - Moving 5+ units in any direction = 1.5 fitness (capped)

         Creatures weren't incentivized to develop real locomotion.

CHANGES:
| Parameter      | Old Value | New Value | Reason                           |
|----------------|-----------|-----------|----------------------------------|
| Multiplier     | 0.3       | 0.5       | More reward per unit moved       |
| Cap            | 1.5       | 3.0       | Higher ceiling for movers        |

CODE (creature.py, get_climbing_fitness):
    movement_bonus = min(distance_moved * 0.5, 3.0)  # Was 0.3, 1.5

WHY: To evolve locomotion, creatures need strong incentive to MOVE. The higher
     cap (3.0) means creatures that develop walking/rolling gaits are rewarded
     more than stationary creatures. Combined with progress reward, this
     encourages movement toward the peak.

================================================================================
15. SELECTION PRESSURE - ADDED MINIMUM FITNESS FLOOR (population.py)
================================================================================

PROBLEM: When all creatures have near-zero fitness (common in early generations
         when no creature has figured out how to move), roulette wheel selection
         becomes essentially RANDOM. This stalls evolution because:
         - fitmap[-1] ≈ 0 when all fitness ≈ 0
         - r * fitmap[-1] ≈ 0 for any random r
         - Selection becomes arbitrary

CHANGES:
| Parameter      | Old Value | New Value | Reason                           |
|----------------|-----------|-----------|----------------------------------|
| min_fitness    | 0         | 0.1       | Ensures meaningful selection     |

CODE (population.py, get_fitness_map):
    def get_fitness_map(fits, min_fitness=0.1):
        for f in fits:
            adjusted_f = f + min_fitness
            total = total + adjusted_f
            fitmap.append(total)

WHY: Adding 0.1 to each fitness ensures:
     1. Even with all zeros, selection still works (uniform but not random)
     2. Small fitness differences still matter (0.1 vs 0.2 = 33% vs 67%)
     3. Creatures with any positive fitness get proportionally selected
     4. Prevents division-by-zero-like behavior in selection

================================================================================
16. CREATURE MORPHOLOGY - VISIBLE EXTENDED LIMBS (genome.py)
================================================================================

PROBLEM: After 800 generations, creatures evolved as single rectangular boxes
         with NO visible limbs. Fitness remained at 0 because creatures had
         no body parts to generate movement. Investigation revealed:

         1. Joint offsets were only 0.1x multiplier - limbs hidden inside body
         2. Link radius (0.65) was too large relative to length (1.3)
         3. Link recurrence scale (2) produced only 1-3 copies
         4. Result: All child links overlapped inside parent = blob/single box

CHANGES:
| Parameter          | Old Value | New Value | Reason                         |
|--------------------|-----------|-----------|--------------------------------|
| link-length scale  | 1.3       | 2         | Longer, more visible limbs     |
| link-radius scale  | 0.65      | 0.4       | Thinner limbs, less overlap    |
| link-recurrence    | 2         | 4         | More limbs (1-5 per gene)      |
| joint xyz offset   | 0.1x      | 0.5x      | Limbs extend further from body |

CODE (genome.py):

1. Gene spec changes (get_gene_spec):
    "link-length": {"scale":2},      # Was 1.3
    "link-radius": {"scale":0.4},    # Was 0.65
    "link-recurrence": {"scale":4},  # Was 2

2. Joint origin offset changes (to_joint_element):
    xyz_1 = self.joint_origin_xyz_1 * 0.5  # Was 0.1
    xyz_2 = self.joint_origin_xyz_2 * 0.5  # Was 0.1
    xyz_3 = parent_len * 0.5 + self.joint_origin_xyz_3 * 0.5  # Was 0.1

WHY: Creatures need VISIBLE, EXTENDED limbs to generate locomotion:
     - Longer limbs (scale 2) can reach the ground and push
     - Thinner limbs (scale 0.4) don't overlap/hide inside each other
     - More recurrence (scale 4) creates more limbs for locomotion
     - Larger joint offsets (0.5x) ensure limbs extend outward from body

     Without these changes, creatures were evolving as single blobs with
     all limbs hidden inside - unable to move no matter how good the
     fitness function or motor settings.

================================================================================
17. PHYSICS ERROR HANDLING - GRACEFUL FAILURE FOR UNSTABLE CREATURES
================================================================================

PROBLEM: With increased limb sizes and recurrence, some creatures generate
         physically unstable configurations that cause PyBullet to "explode"
         them - destroying the physics body mid-simulation. This caused:

         pybullet.error: GetBasePositionAndOrientation failed.

         The error crashed the entire GA run instead of just penalizing
         the unstable creature.

CHANGES:
| Location              | Change                                          |
|-----------------------|-------------------------------------------------|
| URDF loading          | Wrapped in try-except, return early on failure  |
| Simulation loop       | Wrapped in try-except, use spawn pos on failure |
| Creature fitness      | Unstable creatures get ~0 fitness (spawn pos)   |

CODE (simulation.py, run_creature):
    try:
        cid = p.loadURDF(xml_file, physicsClientId=pid)
    except Exception as e:
        cr.update_final_position((0, 0, 0))
        return

    try:
        for step in range(480, iterations):
            # ... simulation loop ...
    except Exception as e:
        cr.update_final_position((spawn_x, spawn_y, spawn_z))

WHY: Evolution naturally produces some invalid/unstable creature designs.
     Rather than crashing, we let these creatures get 0 fitness and be
     selected against. This is actually beneficial - the GA will learn
     to avoid unstable configurations over generations.

================================================================================
18. SIBLING LIMB SPREADING - PREVENT OVERLAPPING LIMBS (genome.py)
================================================================================

PROBLEM: With link-recurrence=4, up to 5 copies of each limb can be created.
         All these siblings were attaching at the EXACT SAME XYZ position:

         Before:
           xyz_1 = self.joint_origin_xyz_1 * 0.5  # Same for ALL siblings
           xyz_2 = self.joint_origin_xyz_2 * 0.5  # Same for ALL siblings

         Only rotation (RPY) varied by sibling_ind, causing all limbs to
         originate from the same point and overlap heavily - creating a
         blob instead of spread-out functional limbs.

CHANGES:
| Parameter      | Old Behavior              | New Behavior                    |
|----------------|---------------------------|--------------------------------|
| xyz_1 (X pos)  | Fixed per gene            | Varies by sibling_ind (+0.2)   |
| xyz_2 (Y pos)  | Fixed per gene            | Varies by sibling_ind (-0.2)   |
| xyz_3 (Z pos)  | 0.5x offset               | 0.3x offset (reduce overlap)   |

CODE (genome.py, to_joint_element):
    spread_factor = (self.sibling_ind - 1) * 0.2
    xyz_1 = self.joint_origin_xyz_1 * 0.5 + spread_factor
    xyz_2 = self.joint_origin_xyz_2 * 0.5 - spread_factor
    xyz_3 = parent_len * 0.5 + self.joint_origin_xyz_3 * 0.3

WHY: Siblings now attach at different positions around the parent:
     - Sibling 1: offset (0, 0)
     - Sibling 2: offset (+0.2, -0.2)
     - Sibling 3: offset (+0.4, -0.4)
     - etc.

     Combined with rotation spreading (RPY * sibling_ind), this creates
     limbs that extend outward in different directions rather than all
     clustering at the same point.
