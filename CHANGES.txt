================================================================================
CM3020 AI COURSEWORK PART B - CODE MODIFICATIONS LOG
================================================================================

This document logs all modifications made to address the PDF Part B requirement:
"get as high as possible up the mountain, without cheating and flying into the air"

================================================================================
SUMMARY OF PREVIOUS APPROACHES (Did Not Work)
================================================================================

We initially attempted to evolve both creature MORPHOLOGY (body shape) and
MOTOR CONTROL (movement patterns) simultaneously. Despite many iterations
and parameter adjustments, this approach consistently failed:

ATTEMPTS MADE:
1. Adjusted fitness function weights (progress, height, movement bonuses)
2. Added ground contact detection and surface penalties
3. Modified joint limits, motor force, and frequency parameters
4. Changed link shapes (cylinders, spheres, boxes)
5. Adjusted joint positioning to prevent overlapping/floating limbs
6. Increased population size and mutation rates
7. Modified spawn position for better climbing gradient

RESULT: After 1000+ generations, fitness remained at 0. Creatures evolved as
        blobs or simple shapes that twitched in place without locomotion.

ROOT CAUSE: The search space for evolving both morphology AND control is
            enormous. Random creatures almost never produce functional bodies,
            and random motor parameters almost never produce coordinated gaits.
            Without any creatures moving, there's no fitness gradient for
            evolution to follow - all creatures score ~0.

================================================================================
NEW APPROACH: FIXED WALKER WITH CONTROL-ONLY EVOLUTION
================================================================================

Following the PDF suggestion (page 4):
"can you start with a fixed design robot, and just evolve the motor control
parameters?"

This approach:
1. Uses a FIXED body design (walker with body + legs)
2. Only evolves MOTOR CONTROL genes (waveform, amplitude, frequency)
3. Dramatically reduces search space (~80% smaller)
4. Creates a fitness gradient that evolution can follow

================================================================================
24. FIXED WALKER GENOME (genome.py)
================================================================================

IMPLEMENTATION: Added get_fixed_walker_genome() method

Creates a fixed walker body structure:
- Gene 0: Body (horizontal cylinder, radius 0.24, length 0.5)
- Gene 1: Legs (3 legs via recurrence, length 0.7, spread around body)

Only motor control genes (indices 14-16) are randomized:
- control-waveform: pulse vs sine wave
- control-amp: motor amplitude
- control-freq: motor frequency

CODE (genome.py):
    @staticmethod
    def get_fixed_walker_genome(gene_length):
        # Gene 0: Body - fixed morphology
        body_gene[0:14] = [fixed values for shape, size, joints]
        body_gene[14:17] = [random motor control values]

        # Gene 1: Legs - fixed morphology
        leg_gene[0:14] = [fixed values for leg shape, attachment]
        leg_gene[14:17] = [random motor control values]

WHY: Fixed body ensures all creatures CAN potentially walk. Evolution only
     needs to find the right motor patterns, not discover body plans from scratch.

================================================================================
25. CONTROL-ONLY MUTATION (genome.py)
================================================================================

IMPLEMENTATION: Added point_mutate_control_only() and crossover_control_only()

These operators ONLY modify motor control genes (indices 14, 15, 16):
- Preserves body morphology across generations
- Allows evolution to focus on finding coordinated motor patterns

CODE (genome.py):
    CONTROL_INDICES = [14, 15, 16]  # waveform, amp, freq

    def point_mutate_control_only(genome, rate, amount):
        for gene in genome:
            for i in CONTROL_INDICES:
                if random.random() < rate:
                    gene[i] += random.uniform(-amount, amount)

    def crossover_control_only(g1, g2):
        # Copy g1's body structure, mix control genes from both parents

WHY: Standard crossover/mutation would corrupt the fixed body structure.
     Control-only operators preserve morphology while evolving motor patterns.

================================================================================
26. MOVEMENT-FIRST FITNESS (creature.py)
================================================================================

IMPLEMENTATION: Rewrote get_climbing_fitness() to prioritize movement

Previous fitness required climbing, but creatures couldn't climb without moving.
New fitness heavily rewards ANY displacement:

    movement_reward = distance_moved * 2.0  # UNCAPPED - more movement = higher fitness
    progress_reward = max(0, progress) * 3.0  # Movement toward peak
    height_reward = max(0, final_height) * 2.0  # Vertical climbing

    fitness = movement_reward + progress_reward + height_reward + 0.1

KEY CHANGES:
- Movement reward has NO CAP (was capped at 3.0)
- Removed surface penalty (was hurting exploration)
- Base 0.1 fitness for any creature that doesn't crash

WHY: Creates a fitness gradient even for random motor patterns. Any creature
     that moves at all will score higher than stationary creatures. This gives
     evolution a signal to follow.

================================================================================
27. FIXED WALKER GA LOOP (test_ga_mountain.py)
================================================================================

IMPLEMENTATION: Rewrote genetic algorithm to use fixed walker approach

KEY CHANGES:
1. Initial population uses fixed walker bodies:
   creatures = [Creature(use_fixed_walker=True) for _ in range(pop_size)]

2. Uses control-only genetic operators:
   dna = genome.Genome.crossover_control_only(p1.dna, p2.dna)
   dna = genome.Genome.point_mutate_control_only(dna, rate=0.4, amount=0.3)

3. NO shrink/grow mutations (body structure is fixed)

4. Higher mutation rate (0.4) since search space is smaller

WHY: Implements the PDF-suggested approach of fixing body design and evolving
     only motor control parameters.

================================================================================
EXPECTED BEHAVIOR
================================================================================

With the new approach:
1. All creatures have identical, functional walker bodies
2. Initial population will have varied motor patterns (random control genes)
3. Some creatures will accidentally move due to random motor oscillations
4. Moving creatures score higher â†’ selected for reproduction
5. Evolution finds coordinated motor patterns that produce locomotion
6. Once locomotion evolves, climbing the mountain becomes possible

The key insight is that evolving motor control for a FIXED body is much easier
than evolving both body AND control simultaneously.

================================================================================
FILES MODIFIED
================================================================================

genome.py:
  - Added get_fixed_walker_genome() - creates fixed body with random motors
  - Added point_mutate_control_only() - mutates only motor genes
  - Added crossover_control_only() - crosses only motor genes

creature.py:
  - Modified __init__() to accept use_fixed_walker parameter
  - Rewrote get_climbing_fitness() for movement-first evaluation

test_ga_mountain.py:
  - Rewrote GA loop to use fixed walker approach
  - Uses control-only genetic operators
  - Removed shrink/grow mutations

================================================================================
